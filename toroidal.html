<!DOCTYPE html>
<html lang="en">
<head>
    		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Toroidal Moment Simulator</title>
		<meta name="description" content="This web app offers an interactive visualization of particle flow through one or more toroidal moments, helping users intuitively explore and understand the underlying geometry.">
		<meta name="robots" content="index, follow">
		<link rel="canonical" href="https://toroidal.midland.org.uk/">
		<meta property="og:title" content="Toroidal Moment Simulator">
		<meta property="og:description" content="This web app offers an interactive visualization of particle flow through one or more toroidal moments, helping users intuitively explore and understand the underlying geometry.">
		<meta property="og:url" content="https://toroidal.midland.org.uk/">
		<meta property="og:type" content="website">
		<meta property="og:image" content="https://toroidal.midland.org.uk/toroidal.png">
    <title>EVO Toroidal Flow - Unified Physics (v17.8 - No Cinematic - Speed Fix)</title> <style>
        /* CSS (Optimized & Updated - Cinematic Removed, Span Added) */
        :root {
            --control-bg: rgba(0, 0, 0, 0.75); --input-bg: #333; --border-color: rgba(100, 100, 100, 0.5);
            --text-color: white; --label-color: #ccc; --header-color: #aaa;
            /* MODIFIED: Slightly darker hover for more contrast */
            --button-bg: #4a5568; --button-hover-bg: #262f3e; /* Darker Hover */
            --view-button-bg: #2d5e70; --view-button-hover-bg: #1a3640; /* Darker Hover */
            /* Preset/Restart Button Colors */
            --preset-restart-bg: #444;
            --preset-restart-hover-bg: #333; /* Darker Hover */
            --preset-reset-bg: #001845;
            --preset-reset-hover-bg: #000c21; /* Darker Hover */
            /* Config Slot Button Colors */
            --config-save-bg: #1a5f7a;
            --config-save-hover-bg: #113e50; /* Darker Hover */
            --config-load-bg: #1f7a8c;
            --config-load-hover-bg: #155561; /* Darker Hover */
            --config-delete-bg: #8c1f1f;
            --config-delete-hover-bg: #5e1414; /* Darker Hover */

            --scrollbar-track: #1a1a1a; --scrollbar-thumb: #444; --scrollbar-thumb-hover: #555;
            --icon-color: #aaa; --icon-active-color: #2a9fd6;
            --overlay-bg: rgba(10, 10, 10, 0.9);
        }
        body { margin: 0; overflow: hidden; background-color: #000; font-family: Arial, sans-serif; color: var(--text-color); }
        canvas { display: block; }
        #controls {
            position: absolute; bottom: 10px; left: 10px; background: var(--control-bg); padding: 5px 8px;
            border-radius: 5px; z-index: 100; max-height: 90vh; overflow-y: auto; overflow-x: hidden;
            transition: opacity 0.5s ease, transform 0.5s ease; /* Slightly slower transition */
            font-size: 70%; max-width: 386px; /* Max width might need adjusting */
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }
        /* REMOVED: #controls.hidden-cinematic */

        #controls::-webkit-scrollbar { width: 8px; }
        #controls::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 4px;}
        #controls::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb); border-radius: 4px; border: 2px solid var(--scrollbar-track); }
        #controls::-webkit-scrollbar-thumb:hover { background-color: var(--scrollbar-thumb-hover); }

        /* Style for moved Reinitiate button */
        #reinitiateButtonContainer {
            padding: 5px 0 8px 0; /* Add some padding */
            margin: 0 5px 8px 5px; /* Add margin */
            border-bottom: 1px solid var(--border-color);
            text-align: center;
        }
        #reinitiateButton {
            background-color: var(--preset-restart-bg);
            border: none; color: var(--text-color); padding: 5px 15px; /* Slightly larger padding */
            border-radius: 4px; cursor: pointer; transition: background-color 0.2s;
            font-size: 95%; /* Larger font size */
            width: 95%; /* Make it wide */
            display: block; margin: 0 auto;
        }
        #reinitiateButton:hover { background-color: var(--preset-restart-hover-bg); }


        .control-section { margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-color); }
        .control-section:first-child { border-top: none; margin-top: 0; padding-top: 0; } /* Adjusted for moved button */
        .control-section summary { font-size: 100%; color: var(--header-color); font-weight: bold; cursor: pointer; padding: 3px 0; list-style: none; }
        .control-section summary::-webkit-details-marker { display: none; }
        .control-section summary::before { content: '‚ñ∂ '; font-size: 80%; }
        .control-section[open] summary::before { content: '‚ñº '; }
        .control-section[open] > *:not(summary) { margin-left: 10px; padding-left: 5px; border-left: 1px dotted #666; }
        .sub-section { margin: 8px 0; padding-top: 8px; border-top: 1px dashed rgba(100, 100, 100, 0.3);}
        .sub-section:first-of-type { border-top: none; padding-top: 0; margin-top: 5px;}
        .sub-section h5 { margin: 3px 0 6px 0; font-size: 95%; color: #999; font-weight: normal; border-bottom: 1px dotted rgba(100,100,100,0.2); padding-bottom: 3px; }

        /* Slider Container Layout for Number Input & Unit Span */
        .slider-container {
             margin: 5px 0; display: flex; align-items: center;
             justify-content: space-between; gap: 4px; /* Reduced gap */
        }
        .slider-container label {
            /* REMOVED: flex: 0 0 36%; */
            flex-basis: 50%; /* Give label more space */
            margin-right: 4px; /* Slightly increased margin */
            white-space: nowrap; font-size: 95%;
            overflow: hidden; text-overflow: ellipsis; color: var(--label-color); cursor: help;
        }
        .slider-container input[type="range"] {
            flex-grow: 1; /* Slider takes remaining space */
            margin: 0; padding: 0; height: 18px; /* Ensure consistent height */
        }
        /* Number Input */
        .slider-container input[type="number"], /* Target number inputs in slider containers */
        .slider-number-input /* Target inputs specifically marked (like simSpeed) */
         {
            flex: 0 0 45px; /* Narrower to make space for unit */
            background-color: var(--input-bg); color: var(--text-color); border: 1px solid #555;
            border-radius: 3px; font-size: 90%; padding: 1px 3px; text-align: right;
            height: 18px; box-sizing: border-box; /* Match height */
            -moz-appearance: textfield; /* Hide spinners in Firefox */
        }
        .slider-container input[type="number"]::-webkit-outer-spin-button,
        .slider-container input[type="number"]::-webkit-inner-spin-button,
        .slider-number-input::-webkit-outer-spin-button, /* Apply spinner hiding to .slider-number-input too */
        .slider-number-input::-webkit-inner-spin-button
         {
            -webkit-appearance: none; /* Hide spinners in Chrome/Safari */
            margin: 0;
        }
        /* Unit Span Styling (General) */
        .slider-container > span,
        .animation-controls > span /* Target span in animation controls */
         {
            flex: 0 0 1em; /* Allocate space for the unit */
            font-size: 90%;
            color: var(--label-color);
            padding-left: 2px; /* Space between number input and unit */
            text-align: left;
            white-space: nowrap;
            flex-shrink: 0; /* Prevent unit span from shrinking */
        }

        /* General input styling */
        .select-container, .checkbox-container, .input-container { margin: 5px 0; display: flex; align-items: center; justify-content: space-between; gap: 5px; }
        .select-container label, .checkbox-container label, .input-container label { flex: 0 0 40%; margin-right: 5px; white-space: nowrap; font-size: 95%; overflow: hidden; text-overflow: ellipsis; color: var(--label-color); cursor: help; }
        .input-container input[type="number"]:not(.slider-number-input), /* Exclude slider number inputs from this rule */
        .input-container input[type="text"] { flex: 1; background-color: var(--input-bg); color: var(--text-color); border: 1px solid #555; border-radius: 3px; font-size: 90%; padding: 1px 3px; width: 50px; text-align: right;}
        .input-container input[type="text"] { text-align: left; width: auto; } /* Specific for text input */
        .select-container select { flex: 1; background-color: var(--input-bg); color: var(--text-color); border: 1px solid #555; border-radius: 3px; font-size: 90%; padding: 2px; }
        .checkbox-container { justify-content: flex-start; }
        .checkbox-container input[type="checkbox"] { margin-right: 8px; flex-shrink: 0;}
        .checkbox-container label { flex: 1; white-space: normal; font-weight: normal; }
        /* Disabled styles */
        input:disabled, select:disabled { opacity: 0.5; cursor: not-allowed; }
        /* Target number input and span based on associated range slider's disabled state via JS now */
        label.disabled { opacity: 0.5; cursor: not-allowed !important; }
        .checkbox-container input:disabled + label { opacity: 0.5; cursor: not-allowed !important; }

        .button-container { margin-top: 10px; padding-top: 8px; border-top: 1px solid var(--border-color); text-align: center; display: flex; flex-wrap: wrap; justify-content: space-around; gap: 5px; }
        .button-container > button, .button-container > select, .support-button, .manual-button {
            background-color: var(--button-bg);
            border: none; color: var(--text-color); padding: 4px 8px;
            border-radius: 4px; cursor: pointer; transition: background-color 0.2s;
            font-size: 85%; flex: 1 1 auto; min-width: 60px; margin-bottom: 3px;
            text-align: center; text-decoration: none; display: inline-block; box-sizing: border-box;
        }
        .button-container > button:hover, .support-button:hover, .manual-button:hover { background-color: var(--button-hover-bg); }
        .button-container > select { padding: 4px 2px; flex-grow: 0; }
        .button-container > select:hover { background-color: var(--input-bg); } /* Basic hover for select */

        #showUIButton { position: absolute; bottom: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.5); border: none; color: var(--text-color); padding: 4px 10px; border-radius: 4px; cursor: pointer; z-index: 90; transition: opacity 0.5s ease, transform 0.5s ease; /* Match controls transition */ opacity: 0; pointer-events: none; font-size: 85%; }
        #showUIButton.visible { opacity: 1; pointer-events: auto; transform: translateX(0); }
        #showUIButton.faded-out { opacity: 0.1 !important; }
        /* REMOVED: #showUIButton.hidden-cinematic */


        #manual-color-controls, #discrete-placement-controls, #eigenmode-controls { display: none; }
        #manual-color-controls.visible, #discrete-placement-controls.visible, #eigenmode-controls.visible { display: flex; flex-direction: column; }
        .hidden { display: none !important; }
        #discreteTotalPoints { font-weight: bold; color: #eee; }
        .discrete-points-display p { margin: 5px 0 0 0; }
        .view-buttons-container { display: flex; flex-wrap: wrap; justify-content: space-around; flex-basis: 100%; margin-top: 5px; gap: 5px; }
        .view-buttons-container button { flex: 1 1 auto; background-color: var(--view-button-bg); min-width: 45px; padding: 4px 6px; font-size: 80%; }
        .view-buttons-container button:hover { background-color: var(--view-button-hover-bg); }
        .animation-controls { display: flex; justify-content: space-around; flex-basis: 100%; margin-top: 5px; gap: 5px; align-items: center; }
        .animation-controls button { min-width: 50px; flex-shrink: 0; } /* Prevent button shrinking */
        .animation-controls label { font-size: 90%; white-space: nowrap; color: var(--label-color); flex-shrink: 0; } /* Prevent label shrinking */
        .animation-controls input[type="range"] { flex-grow: 1; margin: 0 5px; min-width: 50px; } /* Allow slider to grow/shrink */
        /* Styles for speed number input are now handled by the general .slider-number-input rule */

        .preset-controls { display: flex; justify-content: space-around; flex-basis: 100%; margin-top: 5px; gap: 5px; }
        .preset-controls button { flex: 1; color: white; border-radius: 10px; }
        /* #restartSimButton is now #reinitiateButton */
        #resetPresetButton { background-color: var(--preset-reset-bg); }
        #resetPresetButton:hover { background-color: var(--preset-reset-hover-bg); }

        .discrete-link-wrapper { display: flex; align-items: center; justify-content: flex-start; margin-bottom: 2px; padding-left: 10%; }
        .slider-link-icon { cursor: pointer; font-size: 120%; color: var(--icon-color); transition: color 0.2s; user-select: none; margin-right: 5px; }
        .slider-link-icon:hover { color: white; }
        .slider-link-icon.active { color: var(--icon-active-color); }

        .config-slot-controls { display: flex; flex-direction: column; gap: 5px; }
        .config-slot-row { display: flex; gap: 5px; align-items: center; }
        .config-slot-row input[type="text"] { flex-grow: 1; min-width: 100px;}
        .config-slot-row select { flex-grow: 1; }
        .config-slot-row button { flex-shrink: 0; padding: 3px 6px; font-size: 80%; min-width: 50px;}
        #saveConfigButton { background-color: var(--config-save-bg); }
        #saveConfigButton:hover { background-color: var(--config-save-hover-bg); }
        #loadConfigButton { background-color: var(--config-load-bg); }
        #loadConfigButton:hover { background-color: var(--config-load-hover-bg); }
        #deleteConfigButton { background-color: var(--config-delete-bg); }
        #deleteConfigButton:hover { background-color: var(--config-delete-hover-bg); }

        #hotkeysPanel { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: var(--overlay-bg); color: var(--text-color); padding: 20px 30px; border: 1px solid var(--border-color); border-radius: 10px; z-index: 1001; max-width: 400px; max-height: 80vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        #hotkeysPanel h4 { margin-top: 0; color: var(--header-color); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        #hotkeysPanel dl { display: grid; grid-template-columns: auto 1fr; gap: 5px 15px; font-size: 95%; }
        #hotkeysPanel dt { font-weight: bold; color: var(--label-color); }
        #hotkeysPanel dd { margin: 0; }
        #closeHotkeysButton { position: absolute; top: 5px; right: 10px; background: none; border: none; color: var(--label-color); font-size: 150%; font-weight: bold; cursor: pointer; padding: 0 5px; }
        #closeHotkeysButton:hover { color: white; }

        #statsContainer { position: absolute; top: 10px; right: 10px; z-index: 101; cursor: pointer; opacity: 0.8; }
        #statsContainer > div { background: rgba(0,0,0,0.5) !important; } /* Override stats.js default bg */

    </style>
</head>
<body>
    <div id="statsContainer" style="display: none;"></div>

    <div id="controls">
        <div id="reinitiateButtonContainer">
             <button id="reinitiateButton" title="Reinitialize particles with current settings (Shift+R)">Reinitiate</button> </div>

        <details class="control-section" open>
            <summary>Flow Dynamics</summary>
              <div class="slider-container">
                  <label for="flowIntensity" title="Overall speed/energy of the flow">Intensity:</label>
                  <input type="range" id="flowIntensity" min="0" max="1" step="0.01" value="0.5">
                  <input type="number" class="slider-number-input" id="flowIntensityNumber" min="0" max="1" step="0.01" value="0.5">
                  <span></span> <!-- Placeholder for potential unit -->
              </div>
              <div class="slider-container">
                  <label for="flowTwist" title="Ratio of Toroidal/Poloidal speed (>1 means more Toroidal)">Twist:</label>
                  <input type="range" id="flowTwist" min="0.1" max="10" step="0.1" value="2.0">
                  <input type="number" class="slider-number-input" id="flowTwistNumber" min="0.1" max="10" step="0.1" value="2.0">
                   <span></span> <!-- Placeholder for potential unit -->
             </div>
              <div class="slider-container">
                  <label for="flowCouplingFactor" title="Couples inward and rotational speeds (e.g., >0 makes faster rotation increase inward speed)">Flow Coupling:</label>
                  <input type="range" id="flowCouplingFactor" min="-0.5" max="0.5" step="0.01" value="0.0">
                  <input type="number" class="slider-number-input" id="flowCouplingFactorNumber" min="-0.5" max="0.5" step="0.01" value="0.0">
                   <span></span> <!-- Placeholder for potential unit -->
             </div>
              <div class="slider-container">
                  <label for="angularMomentumEffect" title="Original: Increases speed closer to center. Disabled if 'Approx Ang Mom' is checked.">Ang. Momentum:</label>
                  <input type="range" id="angularMomentumEffect" min="0" max="5" step="0.05" value="5.0">
                  <input type="number" class="slider-number-input" id="angularMomentumEffectNumber" min="0" max="5" step="0.05" value="5.0">
                   <span></span> <!-- Placeholder for potential unit -->
             </div>
              <div class="checkbox-container"> <input type="checkbox" id="approximateAngularMomentum" checked> <label for="approximateAngularMomentum" title="Approximate v ~ 1/r for toroidal speed (overrides Ang. Momentum Effect)">Approx. Ang. Mom.</label> </div>
              <div class="slider-container">
                  <label for="windingTheta" title="Constant poloidal drift (radians/sec)">Winding Œ∏:</label>
                  <input type="range" id="windingTheta" min="-5" max="5" step="1" value="0">
                  <input type="number" class="slider-number-input" id="windingThetaNumber" min="-5" max="5" step="1" value="0">
                   <span></span> <!-- Placeholder for potential unit -->
             </div>
              <div class="slider-container">
                  <label for="windingPhi" title="Constant toroidal drift (radians/sec)">Winding œÜ:</label>
                  <input type="range" id="windingPhi" min="-5" max="5" step="1" value="0">
                  <input type="number" class="slider-number-input" id="windingPhiNumber" min="-5" max="5" step="1" value="0">
                   <span></span> <!-- Placeholder for potential unit -->
             </div>
              <div class="slider-container">
                  <label for="solitonPhasing" title="Force pulling particles back towards ideal flow path (if random) or original grid point (if discrete)">Soliton Phasing:</label>
                  <input type="range" id="solitonPhasing" min="0.0" max="0.1" step="0.0001" value="0">
                  <input type="number" class="slider-number-input" id="solitonPhasingNumber" min="0.0" max="0.1" step="0.0001" value="0">
                   <span></span> <!-- Placeholder for potential unit -->
             </div>
              <div class="slider-container">
                  <label for="jitterScale" title="Random positional jitter added each frame (Affects physics)">Jitter Scale:</label>
                  <input type="range" id="jitterScale" min="0" max="50" step="0.1" value="0.0">
                  <input type="number" class="slider-number-input" id="jitterScaleNumber" min="0" max="50" step="0.1" value="0.0">
                   <span></span> <!-- Placeholder for potential unit -->
             </div>

              <div class="sub-section">
                  <h5>Eigenmode Visualization</h5>
                  <div class="checkbox-container"> <input type="checkbox" id="visualizeEigenmode"> <label for="visualizeEigenmode" title="Modulate flow based on theoretical eigenmode (m, n)">Visualize Eigenmode (m, n)</label> </div>
                  <div id="eigenmode-controls" class="eigenmode-controls">
                      <div class="input-container"> <label for="eigenmodeM" title="Poloidal mode number">Mode m:</label> <input type="number" id="eigenmodeM" step="1" value="1"> </div>
                      <div class="input-container"> <label for="eigenmodeN" title="Toroidal mode number">Mode n:</label> <input type="number" id="eigenmodeN" step="1" value="2"> </div>
                      <div class="slider-container">
                          <label for="eigenmodeFlowStrength" title="Strength of the eigenmode flow modulation (+ speeds up crests, - speeds up troughs)">Eigen Strength:</label>
                          <input type="range" id="eigenmodeFlowStrength" min="-0.5" max="0.5" step="0.01" value="0">
                          <input type="number" class="slider-number-input" id="eigenmodeFlowStrengthNumber" min="-0.5" max="0.5" step="0.01" value="0">
                           <span></span> <!-- Placeholder -->
                      </div>
                  </div>
              </div>
              </details>

        <details class="control-section">
            <summary>Geometry & Structure</summary>
              <div class="select-container"> <label for="arrangementMode" title="Arrangement of toroids">Arrangement:</label>
                  <select id="arrangementMode">
                      <option value="single" selected>Single</option>
                      <option value="vesicaPiscis">Vesica Piscis (2)</option>
                      <option value="flowerOfLife2D">Flower of Life (2D - 19)</option>
                      <option value="fruitOfLife">Fruit of Life (2D - 13)</option>
                      <option value="tetrahedron">Platonic: Tetrahedron (4)</option>
                      <option value="cube">Platonic: Cube (8)</option>
                      <option value="octahedron">Platonic: Octahedron (6)</option>
                      <option value="icosahedron">Platonic: Icosahedron (12)</option>
                      <option value="dodecahedron">Platonic: Dodecahedron (20)</option>
                    </select>
                  </div>
              <div class="checkbox-container">
                  <input type="checkbox" id="showTorusGeometry">
                  <label for="showTorusGeometry" title="Render the underlying torus shape as a wireframe">Show Torus Geometry</label>
              </div>
               <div class="slider-container">
                   <label for="tubeRadius" title="Minor radius of the torus tube">Tube Radius (r):</label>
                   <input type="range" id="tubeRadius" min="-10000" max="10000" step="10" value="2940">
                   <input type="number" class="slider-number-input" id="tubeRadiusNumber" min="-10000" max="10000" step="10" value="2940">
                    <span></span> <!-- Placeholder -->
              </div>
               <div class="slider-container">
                   <label for="torusRadius" title="Major radius of the torus / Base scale for arrangements">Torus Radius (R):</label>
                   <input type="range" id="torusRadius" min="-10000" max="10000" step="10" value="3000">
                   <input type="number" class="slider-number-input" id="torusRadiusNumber" min="-10000" max="10000" step="10" value="3000">
                    <span></span> <!-- Placeholder -->
              </div>
               <div class="slider-container">
                   <label for="pulseAmplitude" title="Amplitude of torus radius oscillation">Pulse Amp:</label>
                   <input type="range" id="pulseAmplitude" min="0" max="2000" step="10" value="0">
                   <input type="number" class="slider-number-input" id="pulseAmplitudeNumber" min="0" max="2000" step="10" value="0">
                    <span></span> <!-- Placeholder -->
              </div>
               <div class="slider-container">
                   <label for="pulseFrequency" title="Frequency of torus radius oscillation">Pulse Freq:</label>
                   <input type="range" id="pulseFrequency" min="0" max="2" step="0.01" value="0.5">
                   <input type="number" class="slider-number-input" id="pulseFrequencyNumber" min="0" max="2" step="0.01" value="0.5">
                    <span></span> <!-- Placeholder -->
              </div>
              <div class="sub-section">
                  <h5>Nested Toroids</h5>
                  <div class="slider-container">
                      <label for="numInnerTori" title="Number of nested shells inside the main one(s)">Nested Shells:</label>
                      <input type="range" id="numInnerTori" min="0" max="6" step="1" value="0">
                      <input type="number" class="slider-number-input" id="numInnerToriNumber" min="0" max="6" step="1" value="0">
                       <span></span> <!-- Placeholder -->
                 </div>
                  <div class="slider-container">
                      <label for="innerTorusRatio" title="Size ratio between consecutive nested shells">Shell Ratio:</label>
                      <input type="range" id="innerTorusRatio" min="0.1" max="0.95" step="0.01" value="0.5">
                      <input type="number" class="slider-number-input" id="innerTorusRatioNumber" min="0.1" max="0.95" step="0.01" value="0.5">
                       <span></span> <!-- Placeholder -->
                 </div>
              </div>

              <div class="sub-section">
                  <h5>Particle Placement</h5>
                  <div class="checkbox-container"> <input type="checkbox" id="useDiscretePlacement" checked> <label for="useDiscretePlacement" title="Place particles on a discrete N x M grid instead of randomly (Overrides Particle Count)">Use Discrete Grid (N x M)</label> </div>
                  <div id="discrete-placement-controls" class="discrete-placement-controls">
                      <div class="discrete-link-wrapper">
                          <span id="discreteLinkIcon" class="slider-link-icon" title="Link/Unlink N and M sliders">üîó</span> Link N/M
                      </div>
                      <div class="slider-container">
                          <label for="discreteN" title="Number of poloidal segments">N (Poloidal):</label>
                          <input type="range" id="discreteN" min="4" max="1280" step="1" value="300">
                          <input type="number" class="slider-number-input" id="discreteNNumber" min="4" max="1280" step="1" value="300">
                           <span></span> <!-- Placeholder -->
                     </div>
                      <div class="slider-container">
                          <label for="discreteM" title="Number of toroidal segments">M (Toroidal):</label>
                          <input type="range" id="discreteM" min="4" max="1280" step="1" value="300">
                          <input type="number" class="slider-number-input" id="discreteMNumber" min="4" max="1280" step="1" value="300">
                           <span></span> <!-- Placeholder -->
                     </div>
                      <div class="discrete-points-display"> <p>Total Grid Points: <span id="discreteTotalPoints">N/A</span></p> </div>
                  </div>
              </div>
           </details>

        <details class="control-section">
            <summary>Particles & Appearance</summary>
              <div class="slider-container">
                  <label for="particleCount" id="particleCountLabel" title="Total number of particles (Auto-set in Discrete Mode)">Particles (k):</label> <!-- Changed Label -->
                  <input type="range" id="particleCount" min="1000" max="500000" step="1000" value="90000">
                  <input type="number" class="slider-number-input" id="particleCountNumber" min="1" max="500" step="1" value="90"> <!-- Changed Range/Step/Value -->
                  <span>k</span> <!-- Unit Span -->
              </div>
              <div class="slider-container">
                  <label for="particleSize" title="Base size of particles">Particle Size:</label>
                  <input type="range" id="particleSize" min="0.1" max="20" step="0.1" value="1.0">
                  <input type="number" class="slider-number-input" id="particleSizeNumber" min="0.1" max="20" step="0.1" value="1.0">
                   <span></span> <!-- Placeholder -->
             </div>
              <div class="slider-container">
                  <label for="energyIntensity" title="Affects particle glow/brightness (visual only)">Energy Intensity:</label>
                  <input type="range" id="energyIntensity" min="0" max="500" step="1" value="50">
                  <input type="number" class="slider-number-input" id="energyIntensityNumber" min="0" max="500" step="1" value="50">
                   <span></span> <!-- Placeholder -->
             </div>
              <div class="slider-container">
                  <label for="particleOpacity" title="Base opacity of particles">Base Opacity:</label>
                  <input type="range" id="particleOpacity" min="0.0" max="1.0" step="0.01" value="0.8">
                  <input type="number" class="slider-number-input" id="particleOpacityNumber" min="0.0" max="1.0" step="0.01" value="0.8">
                   <span></span> <!-- Placeholder -->
             </div>
              <div class="slider-container">
                  <label for="particleOpacityVariation" title="Adds randomness BELOW base opacity (0=none, 1=can go to 0)">Opacity Var:</label>
                  <input type="range" id="particleOpacityVariation" min="0.0" max="1.0" step="0.01" value="0.0">
                  <input type="number" class="slider-number-input" id="particleOpacityVariationNumber" min="0.0" max="1.0" step="0.01" value="0.0">
                   <span></span> <!-- Placeholder -->
             </div>
              <div class="slider-container">
                  <label for="opacityFromCamera" title="Fade opacity based on distance from camera (0=none, 1=max effect)">Opacity/Cam:</label>
                  <input type="range" id="opacityFromCamera" min="0.0" max="1.0" step="0.01" value="0.0">
                  <input type="number" class="slider-number-input" id="opacityFromCameraNumber" min="0.0" max="1.0" step="0.01" value="0.0">
                   <span></span> <!-- Placeholder -->
             </div>

              <div class="sub-section">
                  <h5>Coloring</h5>
                  <div class="select-container">
                      <label for="colorMode" title="Parameter used to determine particle color">Color Mode:</label>
                      <select id="colorMode">
                          <option value="manual" selected>Manual RGB</option>
                          <option value="velocity">Velocity</option>
                          <option value="directionChange">Direction Change</option>
                          <option value="poloidal">Poloidal Angle</option>
                          <option value="toroidal">Toroidal Angle</option>
                          <option value="radialTube">Radial Pos (Tube)</option>
                          <option value="radialXY">Radial Pos (XY)</option>
                          <option value="distFromR">Dist from R</option>
                          <option value="anglesHL">Angles (H=Tor, L=Pol)</option>
                          <option value="eigenmodePhase">Eigenmode Phase</option>
                          <option value="xyz">XYZ Position</option>
                      </select>
                  </div>
                  <div id="manual-color-controls">
                      <div class="slider-container">
                          <label for="particleColorR">Red:</label>
                          <input type="range" id="particleColorR" min="0" max="1" step="0.01" value="0.39">
                          <input type="number" class="slider-number-input" id="particleColorRNumber" min="0" max="1" step="0.01" value="0.39">
                           <span></span> <!-- Placeholder -->
                     </div>
                      <div class="slider-container">
                          <label for="particleColorG">Green:</label>
                          <input type="range" id="particleColorG" min="0" max="1" step="0.01" value="0.62">
                          <input type="number" class="slider-number-input" id="particleColorGNumber" min="0" max="1" step="0.01" value="0.62">
                           <span></span> <!-- Placeholder -->
                     </div>
                      <div class="slider-container">
                          <label for="particleColorB">Blue:</label>
                          <input type="range" id="particleColorB" min="0" max="1" step="0.01" value="1.00">
                          <input type="number" class="slider-number-input" id="particleColorBNumber" min="0" max="1" step="0.01" value="1.00">
                           <span></span> <!-- Placeholder -->
                     </div>
                      <div class="slider-container">
                          <label for="particleColorVariation" title="Random variation applied to manual color">Color Variation:</label>
                          <input type="range" id="particleColorVariation" min="0" max="1" step="0.01" value="1.0">
                          <input type="number" class="slider-number-input" id="particleColorVariationNumber" min="0" max="1" step="0.01" value="1.0">
                           <span></span> <!-- Placeholder -->
                     </div>
                  </div>
              </div>

              <div class="sub-section">
                  <h5>Post-Processing Effects</h5>
                  <div class="checkbox-container"> <input type="checkbox" id="enableTrails" checked> <label for="enableTrails" title="Enable motion trail effect (Post-processing)">Enable Trails</label> </div>
                  <div class="slider-container">
                      <label for="trailDecay" title="How quickly trails fade (lower = longer trails)">Trail Decay:</label>
                      <input type="range" id="trailDecay" min="0.0" max="0.998" step="0.001" value="0.938">
                      <input type="number" class="slider-number-input" id="trailDecayNumber" min="0.0" max="0.998" step="0.001" value="0.938">
                       <span></span> <!-- Placeholder -->
                 </div>
                  <div class="checkbox-container"> <input type="checkbox" id="enableBloom" checked> <label for="enableBloom" title="Enable bloom glow effect (Post-processing)">Enable Bloom</label> </div>
                  </div>
           </details>

        <details class="control-section">
            <summary>Configuration Slots</summary>
            <div class="config-slot-controls">
                <div class="config-slot-row input-container">
                    <label for="configNameInput">Save Name:</label>
                    <input type="text" id="configNameInput" placeholder="Enter config name">
                    <button id="saveConfigButton" title="Save current settings with the specified name">Save As</button>
                </div>
                <div class="config-slot-row select-container">
                    <label for="configSelect">Load/Delete:</label>
                    <select id="configSelect">
                        <option value="">-- Select Saved Config --</option>
                        </select>
                    <button id="loadConfigButton" title="Load settings from the selected configuration">Load</button>
                    <button id="deleteConfigButton" title="Delete the selected configuration">Delete</button>
                </div>
            </div>
        </details>

        <div class="button-container">
            <button id="toggleUIButton" title="Show/Hide this control panel (H)">Hide UI</button>
            <button id="showHotkeysButton" title="Display keyboard shortcuts">Hotkeys</button>
            <button id="toggleStatsButton" title="Show/Hide Performance Stats">Stats</button>
            <a href="https://toroidal.midland.org.uk/readme.txt" target="_blank" rel="noopener noreferrer" class="manual-button" title="Open User Manual">Manual</a>
            <a href="https://buymeacoffee.com/6af1sbu" target="_blank" rel="noopener noreferrer" class="support-button" title="Support the Developer">Support</a>

            <div class="animation-controls">
                <button id="playPauseButton" title="Play/Pause Simulation (Space)">Pause</button>
                <label for="simSpeed">Speed:</label>
                <input type="range" id="simSpeed" min="0.1" max="5.0" step="0.1" value="1.0" title="Simulation Speed Multiplier">
                <input type="number" class="slider-number-input" id="simSpeedNumber" min="0.1" max="5.0" step="0.1" value="1.0">
                 <span>x</span> <!-- Unit Span -->
           </div>
            <div class="preset-controls">
                <button id="resetPresetButton" title="Reset all settings to defaults and clear ALL saved state (Shift+Del)">‚ö†Ô∏è Reset All</button>
            </div>
            <div class="view-buttons-container">
                <button id="snapTopViewButton" title="View from Top (T)">Top</button>
                <button id="snapBottomViewButton" title="View from Bottom">Bottom</button>
                <button id="snapFrontViewButton" title="View from Front (F)">Front</button>
                <button id="snapBackViewButton" title="View from Back">Back</button>
                <button id="snapLeftViewButton" title="View from Left (L)">Left</button>
                <button id="snapRightViewButton" title="View from Right">Right</button>
                <button id="snapIsoNEButton" title="Isometric View (I)">Iso NE</button>
                <button id="snapIsoNWButton" title="Isometric View">Iso NW</button>
                <button id="snapIsoSEButton" title="Isometric View">Iso SE</button>
                <button id="snapIsoSWButton" title="Isometric View">Iso SW</button>
            </div>
        </div>
        </div>
    <button id="showUIButton" title="Show UI Panel (H)">Show UI</button>

    <div id="hotkeysPanel">
        <button id="closeHotkeysButton" title="Close Hotkeys Panel">&times;</button>
        <h4>Keyboard Shortcuts</h4>
        <dl>
            <dt>Space</dt><dd>Play / Pause Simulation</dd>
            <dt>H</dt><dd>Show / Hide UI Panel</dd>
            <dt>Shift + R</dt><dd>Reinitiate Simulation</dd>
            <dt>Shift + Delete</dt><dd>Reset All Settings (Clears Saved States)</dd>
            <dt>T</dt><dd>Snap View to Top</dd>
            <dt>F</dt><dd>Snap View to Front</dd>
            <dt>L</dt><dd>Snap View to Left</dd>
            <dt>I</dt><dd>Snap View to Isometric NE</dd>
            <dt>Escape</dt><dd>Close this Hotkeys Panel / Blur Input</dd>
            <!-- REMOVED: Cinematic hotkey -->
        </dl>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/AfterimagePass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/AfterimageShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script>
        // --- Global Scope ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000);
        const initialCameraPosition = { x: 0, y: 0, z: 10000 };
        const initialCameraRotation = { x: 0, y: 0 };
        camera.position.z = initialCameraPosition.z;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        document.body.appendChild(renderer.domElement);
        const clock = new THREE.Clock();
        let frameCount = 0;
        const ambientLight = new THREE.AmbientLight(0x333333); scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); directionalLight.position.set(1, 1, 1); scene.add(directionalLight);

        const stats = new Stats();
        const statsContainer = document.getElementById('statsContainer');
        if (statsContainer) statsContainer.appendChild(stats.dom);

        const localStorageKeyPrefix = 'torusSimPreset_v17.8_noCine_fix1'; // Updated version marker
        const autoSaveKey = `${localStorageKeyPrefix}_autosave`;
        const namedSlotPrefix = `${localStorageKeyPrefix}_slot_`;

        // --- Simulation State (v17.8 Defaults - Cinematic Removed) ---
        let simState = {
            // Flow Dynamics
            flowIntensity: 0.5, flowTwist: 2.0, flowCouplingFactor: 0.0,
            angularMomentumEffect: 5.0, approximateAngularMomentum: true,
            windingTheta: 0, windingPhi: 0, solitonPhasing: 0.0,
            jitterScale: 0.0, visualizeEigenmode: false, eigenmodeM: 1, eigenmodeN: 2, eigenmodeFlowStrength: 0.0,
            // Geometry & Structure
            arrangementMode: 'single', tubeRadius: 2940, torusRadius: 3000, pulseAmplitude: 0.0, pulseFrequency: 0.5,
            numInnerTori: 0, innerTorusRatio: 0.5, useDiscretePlacement: true, discreteN: 300, discreteM: 300,
            discreteSlidersLinked: true,
            showTorusGeometry: false,
            // Particles & Appearance
            userParticleCount: 90000, particleCount: 90000, particleSize: 1.0, energyIntensity: 50.0,
            particleOpacity: 0.8, particleOpacityVariation: 0.0, opacityFromCamera: 0.0,
            colorMode: 'manual', particleColorR: 0.39, particleColorG: 0.62, particleColorB: 1.00, particleColorVariation: 1.0,
            // Post-Processing
            enableTrails: true, trailDecay: 0.938, enableBloom: true,
            // Animation & UI
            isPaused: false, simSpeed: 1.0, uiVisible: true, showStats: false,
            // Camera
            cameraPosition: { ...initialCameraPosition }, cameraRotation: { ...initialCameraRotation },
            targetCameraRotation: { ...initialCameraRotation }
            // REMOVED: Cinematic Camera State
        };

        // --- Cinematic Camera State Removed ---
        // let lastInteractionTime = Date.now(); // REMOVED
        // const CINEMATIC_TIMEOUT = 15000; // REMOVED
        // let cinematicModeTimer = null; // REMOVED

        // --- Three.js Setup & Helpers ---
        const shellColors = [
             new THREE.Color(0xFF00FF), new THREE.Color(0x4B0082), new THREE.Color(0x0000FF), new THREE.Color(0x00FF00),
             new THREE.Color(0xFFFF00), new THREE.Color(0xFF7F00), new THREE.Color(0xFF0000)
            ];
        const defaultParticleColor = new THREE.Color(0xcccccc);
        const arrangementGroup = new THREE.Group(); scene.add(arrangementGroup);
        const torusGeometryGroup = new THREE.Group(); scene.add(torusGeometryGroup);
        const torusWireframeMaterial = new THREE.MeshBasicMaterial({ color: 0x00cc44, wireframe: true, transparent: true, opacity: 0.3 });

        const particlesMaterial = new THREE.PointsMaterial({ size: simState.particleSize, vertexColors: true, transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending, sizeAttenuation: true, depthWrite: false });
        const maxParticleCount = 500000;
        const tempColor = new THREE.Color(); const tempVec3 = new THREE.Vector3(); const tempVec3_2 = new THREE.Vector3(); const worldUp = new THREE.Vector3(0, 1, 0); const twoPi = Math.PI * 2; const epsilon = 0.00001;
        const MAX_EXPECTED_SPEED = 1500;
        const MAX_FLOW_SPEED = 1.0; // *** INCREASED *** from 0.03 - Represents base angular speed (radians/sec?) at intensity 1
        const ARRANGEMENT_BASE_SCALE_FACTOR = 2.0; const ARRANGEMENT_3D_CONTRACTION = 0.7; const phiGolden = (1 + Math.sqrt(5)) / 2;
        // const BASE_WIND_STEP = 0.01; // Removed - Winding is now directly used as rad/sec
        const MAX_POS_EXTENT = 10000;

        // --- Post Processing Setup ---
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        const afterimagePass = new THREE.AfterimagePass();
        afterimagePass.uniforms["damp"].value = simState.trailDecay;
        const bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
        bloomPass.threshold = 0.2; bloomPass.strength = 0.6; bloomPass.radius = 0.55;

        let isDragging = false; let previousMousePosition = { x: 0, y: 0 };
        const cameraTransitionSpeed = 0.08;

        // --- Velocity Tracking ---
        let previousVelocities = null;
        const prevVelVec = new THREE.Vector3(); const currVelVec = new THREE.Vector3(); const normPrev = new THREE.Vector3(); const normCurr = new THREE.Vector3();

        // --- Helper Functions ---
        function calculateEigenvalue(m, n, r, R) { if(Math.abs(r)<epsilon||Math.abs(R)<epsilon) return NaN; return -((m*m)/(r*r)+(n*n)/(R*R)); }
        function randomOffset(scale) { return (Math.random() - 0.5) * 2 * scale; }
        function lerp(start, end, t) { return start * (1 - t) + end * t; }
        function angleLerp(a0, a1, t) { const max = Math.PI * 2; const da = (a1 - a0) % max; return a0 + (((2 * da) % max) - da) * t; }
        function debounce(func, wait) {
             let timeout;
             return function executedFunction(...args) {
                 const later = () => { clearTimeout(timeout); func(...args); };
                 clearTimeout(timeout);
                 timeout = setTimeout(later, wait);
             };
        }
        // --- END Helper Functions ---


        // --- Arrangement Offset Calculation ---
        function getArrangementOffsets(mode, baseRadius) {
            const offsets = [];
            const S_base = Math.max(100, Math.abs(baseRadius)) * ARRANGEMENT_BASE_SCALE_FACTOR;
            const R_fol = S_base / ARRANGEMENT_BASE_SCALE_FACTOR;
            const S_3d = S_base * ARRANGEMENT_3D_CONTRACTION;
            const sqrt3 = Math.sqrt(3); const cos = Math.cos; const sin = Math.sin; const PI = Math.PI; const ang120 = 2 * PI / 3; const ang60 = PI / 3;
            switch (mode) {
                 case 'flowerOfLife2D': offsets.push({ x: 0, y: 0, z: 0 }); for (let i = 0; i < 6; i++) { offsets.push({ x: R_fol * cos(i * ang60), y: R_fol * sin(i * ang60), z: 0 }); } const Rsqrt3_FoL = R_fol * sqrt3; for (let i = 0; i < 6; i++) { offsets.push({ x: Rsqrt3_FoL * cos(PI / 6 + i * ang60), y: Rsqrt3_FoL * sin(PI / 6 + i * ang60), z: 0 }); } const R2_FoL = 2 * R_fol; for (let i = 0; i < 6; i++) { offsets.push({ x: R2_FoL * cos(i * ang60), y: R2_FoL * sin(i * ang60), z: 0 }); } break;
                 case 'fruitOfLife': offsets.push({ x: 0, y: 0, z: 0 }); for (let i = 0; i < 6; i++) { offsets.push({ x: R_fol * cos(i * ang60), y: R_fol * sin(i * ang60), z: 0 }); } const Rsqrt3_Fruit = R_fol * sqrt3; for (let i = 0; i < 6; i++) { offsets.push({ x: Rsqrt3_Fruit * cos(PI / 6 + i * ang60), y: Rsqrt3_Fruit * sin(PI / 6 + i * ang60), z: 0 }); } break;
                 case 'vesicaPiscis': offsets.push({ x: -R_fol / 2, y: 0, z: 0 }); offsets.push({ x: R_fol / 2, y: 0, z: 0 }); break;
                 case 'tetrahedron': const st = S_3d * 0.6; offsets.push({ x: st, y: st, z: st }); offsets.push({ x: st, y: -st, z: -st }); offsets.push({ x: -st, y: st, z: -st }); offsets.push({ x: -st, y: -st, z: st }); break;
                 case 'cube': const sc = S_3d * 0.6; for (let i = -1; i <= 1; i += 2) { for (let j = -1; j <= 1; j += 2) { for (let k = -1; k <= 1; k += 2) { offsets.push({ x: i * sc, y: j * sc, z: k * sc }); } } } break;
                 case 'octahedron': const so = S_3d * 0.8; offsets.push({ x: so, y: 0, z: 0 }); offsets.push({ x: -so, y: 0, z: 0 }); offsets.push({ x: 0, y: so, z: 0 }); offsets.push({ x: 0, y: -so, z: 0 }); offsets.push({ x: 0, y: 0, z: so }); offsets.push({ x: 0, y: 0, z: -so }); break;
                 case 'icosahedron': const si = S_3d * 0.5; offsets.push({x: 0, y: si, z: si * phiGolden}); offsets.push({x: 0, y: -si, z: si * phiGolden}); offsets.push({x: 0, y: si, z: -si * phiGolden}); offsets.push({x: 0, y: -si, z: -si * phiGolden}); offsets.push({y: 0, z: si, x: si * phiGolden}); offsets.push({y: 0, z: -si, x: si * phiGolden}); offsets.push({y: 0, z: si, x: -si * phiGolden}); offsets.push({y: 0, z: -si, x: -si * phiGolden}); offsets.push({z: 0, x: si, y: si * phiGolden}); offsets.push({z: 0, x: -si, y: si * phiGolden}); offsets.push({z: 0, x: si, y: -si * phiGolden}); offsets.push({z: 0, x: -si, y: -si * phiGolden}); break;
                 case 'dodecahedron': const sd = S_3d * 0.4; const sd_phi = sd * phiGolden; const sd_phi_inv = sd / phiGolden; for (let i = -1; i <= 1; i += 2) { for (let j = -1; j <= 1; j += 2) { offsets.push({x: 0, y: i * sd_phi_inv, z: j * sd_phi }); offsets.push({y: 0, z: i * sd_phi_inv, x: j * sd_phi }); offsets.push({z: 0, x: i * sd_phi_inv, y: j * sd_phi }); for (let k = -1; k <= 1; k += 2) { offsets.push({ x: i * sd, y: j * sd, z: k * sd }); } } } break;
                 case 'single': default: offsets.push({ x: 0, y: 0, z: 0 }); break;
             }
             return offsets;
        }

        // --- Torus Geometry Update ---
        function updateTorusGeometryMeshes() {
            while (torusGeometryGroup.children.length > 0) {
                 const child = torusGeometryGroup.children[0];
                 if (child.geometry) child.geometry.dispose();
                 torusGeometryGroup.remove(child);
             }
            if (!simState.showTorusGeometry) return;

            let baseEffR = simState.torusRadius; let baseEffr = simState.tubeRadius;
            if (simState.pulseAmplitude > 0 && simState.pulseFrequency > 0 && !simState.isPaused) {
                 const time = clock.getElapsedTime(); const pf = simState.pulseAmplitude * Math.sin(time * simState.pulseFrequency * twoPi); baseEffR += pf; baseEffr += pf * 0.5;
                 if (Math.abs(baseEffR) <= Math.abs(baseEffr)) { baseEffR = (Math.sign(baseEffR) || 1) * (Math.abs(baseEffr) + epsilon); }
                 baseEffR = Math.sign(baseEffR) * Math.max(epsilon, Math.abs(baseEffR)); baseEffr = Math.sign(baseEffr) * Math.max(epsilon, Math.abs(baseEffr));
            }
             const geomR = Math.max(epsilon, Math.abs(baseEffR)); const geomr = Math.max(epsilon, Math.abs(baseEffr));

            const offsets = getArrangementOffsets(simState.arrangementMode, simState.torusRadius);
             // INCREASED RESOLUTION: 4x original values
            const radialSegments = 128; // Was 32
            const tubularSegments = 64; // Was 16

            for (let i = 0; i < offsets.length; i++) {
                 const offset = offsets[i]; const torusGeom = new THREE.TorusGeometry(geomR, geomr, radialSegments, tubularSegments);
                 const torusMesh = new THREE.Mesh(torusGeom, torusWireframeMaterial); torusMesh.position.set(offset.x, offset.y, offset.z);
                 if (simState.arrangementMode === 'flowerOfLife2D') { torusMesh.rotation.z = Math.PI / 6; } else { torusMesh.rotation.set(0, 0, 0); }
                 torusGeometryGroup.add(torusMesh);
             }
        }

        // --- Particle System Creation ---
        function createParticleSystem(targetTotalCount) {
             const oldSinglePS = scene.getObjectByName('particleSystem'); if (oldSinglePS) { if (oldSinglePS.geometry) oldSinglePS.geometry.dispose(); scene.remove(oldSinglePS); }
             while (arrangementGroup.children.length > 0) { const child = arrangementGroup.children[0]; if (child.geometry) child.geometry.dispose(); arrangementGroup.remove(child); } arrangementGroup.rotation.set(0, 0, 0);
             let actualTotalParticles = 0; arrangementGroup.visible = false; let currentTargetCount = targetTotalCount;
             if (simState.useDiscretePlacement && simState.discreteN > 0 && simState.discreteM > 0) { currentTargetCount = simState.discreteN * simState.discreteM; if (simState.userParticleCount !== currentTargetCount) { simState.userParticleCount = currentTargetCount; } }
             if (simState.arrangementMode === 'single') { const singleGeom = createSingleTorusGeometry(currentTargetCount); if (singleGeom) { actualTotalParticles = singleGeom.attributes.position.count; const singleMesh = new THREE.Points(singleGeom, particlesMaterial); singleMesh.name = 'particleSystem'; scene.add(singleMesh); } }
             else { arrangementGroup.visible = true; const offsets = getArrangementOffsets(simState.arrangementMode, simState.torusRadius); const numObjects = offsets.length; if (numObjects === 0) { console.error("No offsets defined for mode:", simState.arrangementMode); simState.particleCount = 0; return; } const particlesPerObject = Math.max(1, Math.floor(currentTargetCount / numObjects)); let totalParticlesInArrangement = 0; for (let i = 0; i < numObjects; i++) { const offset = offsets[i]; const torusGeom = createSingleTorusGeometry(particlesPerObject); if (torusGeom) { const meshParticleCount = torusGeom.attributes.position.count; totalParticlesInArrangement += meshParticleCount; const torusMesh = new THREE.Points(torusGeom, particlesMaterial); torusMesh.name = `torus_${i}`; torusMesh.position.set(offset.x, offset.y, offset.z); arrangementGroup.add(torusMesh); } } actualTotalParticles = totalParticlesInArrangement; if (simState.arrangementMode === 'flowerOfLife2D') { arrangementGroup.rotation.z = Math.PI / 6; } else { arrangementGroup.rotation.set(0,0,0); } }
             simState.particleCount = actualTotalParticles;
             if (!previousVelocities || previousVelocities.length !== actualTotalParticles * 3) { previousVelocities = new Float32Array(actualTotalParticles * 3); console.log("Initialized global previousVelocities array with size:", previousVelocities.length); }
             else { previousVelocities.fill(0); } // Reset velocities on rebuild

             // Update UI for particle count (state var userParticleCount, control 'particleCount')
             updateControlValue('particleCount', simState.userParticleCount, controlsConfig.particleCount);
             updateDiscretePointsDisplay();
             toggleParticleCountSlider(!simState.useDiscretePlacement);
             updateTorusGeometryMeshes(); // Update torus geometry too
        }

        // --- Particle Geometry Creation ---
        function createSingleTorusGeometry(count) {
             if (count <= 0) return null; count = Math.min(count, maxParticleCount);
             const newPosArray = new Float32Array(count * 3); const newColorArray = new Float32Array(count * 4);
             const totalShells = simState.numInnerTori + 1; const approxParticlesPerShell = totalShells > 0 ? Math.max(1, Math.floor(count / totalShells)) : 0;
             let particlesPlaced = 0; let baseTR = simState.torusRadius; let baseTuR = simState.tubeRadius;
             if (Math.abs(baseTR) <= Math.abs(baseTuR)) { baseTR = (Math.sign(baseTR) || 1) * (Math.abs(baseTuR) + epsilon); }
             let placeTR = Math.sign(baseTR) * Math.max(epsilon, Math.abs(baseTR)); let placeTuR = Math.sign(baseTuR) * Math.max(epsilon, Math.abs(baseTuR));
             const useDiscrete = simState.useDiscretePlacement && simState.discreteN > 0 && simState.discreteM > 0; const geomStepN = useDiscrete ? twoPi / simState.discreteN : 0; const geomStepM = useDiscrete ? twoPi / simState.discreteM : 0; const numGridPoints = useDiscrete ? simState.discreteN * simState.discreteM : 0; const maxXYRad = Math.abs(placeTR) + Math.abs(placeTuR);
             for (let shellIndex = 0; shellIndex < totalShells; shellIndex++) { const shellRatio = Math.pow(simState.innerTorusRatio, shellIndex); let currentPlaceTR = placeTR * shellRatio; let currentPlaceTuR = placeTuR * shellRatio; if (Math.abs(currentPlaceTR) <= Math.abs(currentPlaceTuR)) { currentPlaceTR = (Math.sign(currentPlaceTR) || 1) * (Math.abs(currentPlaceTuR) + epsilon); } currentPlaceTR = Math.sign(currentPlaceTR) * Math.max(epsilon, Math.abs(currentPlaceTR)); currentPlaceTuR = Math.sign(currentPlaceTuR) * Math.max(epsilon, Math.abs(currentPlaceTuR)); const shellColor = shellColors[shellIndex % shellColors.length] || defaultParticleColor; const countForThisShell = (shellIndex === totalShells - 1) ? count - particlesPlaced : Math.min(approxParticlesPerShell, count - particlesPlaced); const effectiveTotal = countForThisShell;
                 for (let j = 0; j < countForThisShell; j++) { const i = particlesPlaced + j; const effectiveIndex = j; let a1, a2; if (useDiscrete && effectiveTotal > 0 && numGridPoints > 0) { const scaledGi = (effectiveIndex / Math.max(1, effectiveTotal)) * numGridPoints; const gi = Math.floor(scaledGi); const clampedGi = Math.max(0, Math.min(numGridPoints - 1, gi)); const mi = clampedGi % simState.discreteM; const ni = Math.floor(clampedGi / simState.discreteM); a1 = mi * geomStepM; a2 = ni * geomStepN; if (effectiveTotal > numGridPoints) { a1 += (Math.random() - 0.5) * geomStepM * 0.5; a2 += (Math.random() - 0.5) * geomStepN * 0.5; } } else { a1 = Math.random() * twoPi; a2 = Math.random() * twoPi; } const posIdx = i * 3; const colorIdx = i * 4; const cosA2 = Math.cos(a2); const x = (currentPlaceTR + currentPlaceTuR * cosA2) * Math.cos(a1); const y = (currentPlaceTR + currentPlaceTuR * cosA2) * Math.sin(a1); const z = currentPlaceTuR * Math.sin(a2); newPosArray[posIdx] = x; newPosArray[posIdx + 1] = y; newPosArray[posIdx + 2] = z;
                     if (simState.colorMode === 'manual' && totalShells > 1) { tempColor.copy(shellColor); const variation = Math.random() * simState.particleColorVariation; tempColor.offsetHSL(0, (Math.random()-0.5) * variation * 0.5, (Math.random()-0.5) * variation*0.2); tempColor.r = Math.max(0, Math.min(1, tempColor.r)); tempColor.g = Math.max(0, Math.min(1, tempColor.g)); tempColor.b = Math.max(0, Math.min(1, tempColor.b)); }
                     else if (simState.colorMode === 'manual') { const variation = Math.random() * simState.particleColorVariation; tempColor.setRGB( Math.max(0, Math.min(1, simState.particleColorR - variation * simState.particleColorR)), Math.max(0, Math.min(1, simState.particleColorG - variation * simState.particleColorG)), Math.max(0, Math.min(1, simState.particleColorB - variation * simState.particleColorB)) ); }
                     else { switch (simState.colorMode) { case 'velocity': case 'directionChange': tempColor.setRGB(0.8,0.8,0.8); break; case 'poloidal': tempColor.setHSL(a2/twoPi, 1.0, 0.5); break; case 'radialTube': const nD=Math.abs(Math.sin(a2)); const v=1.0-nD*0.6; tempColor.setHSL(a1/twoPi, 1.0, Math.max(0.2,v)); break; case 'toroidal': tempColor.setHSL(a1/twoPi, 0.9, 0.55); break; case 'radialXY': const xyRad = Math.sqrt(x*x + y*y); tempColor.setHSL(0.7, 1.0, Math.min(1.0, xyRad / (maxXYRad + epsilon))); break; case 'distFromR': const distR = Math.abs(Math.sqrt(x*x + y*y) - currentPlaceTR); tempColor.setHSL(0.3, 1.0, Math.min(1.0, distR / (Math.abs(currentPlaceTuR) + epsilon))); break; case 'anglesHL': tempColor.setHSL(a1 / twoPi, 1.0, 0.5 + 0.4 * Math.sin(a2)); break; case 'eigenmodePhase': const phase=(simState.eigenmodeM*a2+simState.eigenmodeN*a1); tempColor.setHSL((phase/twoPi+1.0)%1.0, 1.0, 0.5); break; case 'xyz': const nX=(x/MAX_POS_EXTENT+1)/2; const nY=(y/MAX_POS_EXTENT+1)/2; const nZ=(z/MAX_POS_EXTENT+1)/2; tempColor.setRGB(Math.max(0,Math.min(1,nX)),Math.max(0,Math.min(1,nY)),Math.max(0,Math.min(1,nZ))); break; default: tempColor.copy(defaultParticleColor); } }
                     newColorArray[colorIdx] = tempColor.r; newColorArray[colorIdx + 1] = tempColor.g; newColorArray[colorIdx + 2] = tempColor.b; newColorArray[colorIdx + 3] = 1.0; // Init Alpha
                 } particlesPlaced += countForThisShell;
             } const newGeom = new THREE.BufferGeometry(); newGeom.setAttribute('position', new THREE.BufferAttribute(newPosArray, 3)); newGeom.setAttribute('color', new THREE.BufferAttribute(newColorArray, 4)); newGeom.computeBoundingSphere(); return newGeom;
        }

        // --- Particle Position & Opacity Update (FIXED delta scaling) ---
        function updateParticlePositions(mesh, currentGeom, baseEffR, baseEffr, delta, particleOffset) {
             if (!previousVelocities || previousVelocities.length < (particleOffset + currentGeom.attributes.position.count) * 3) { console.error("PrevVelocities mismatch/uninit for mesh", mesh.name, "Required:", (particleOffset + currentGeom.attributes.position.count) * 3, "Available:", previousVelocities?.length); return; }
             if (delta <= 0 || !currentGeom?.attributes?.position?.array || !currentGeom?.attributes?.color?.array) return; // delta here is simDelta

             const pos = currentGeom.attributes.position.array; const colors = currentGeom.attributes.color.array; const colorAttribute = currentGeom.attributes.color; const count = currentGeom.attributes.position.count;
             let needsDynamicRGBUpdate = ( simState.colorMode === 'velocity' || simState.colorMode === 'directionChange' || simState.colorMode === 'eigenmodePhase' );

             const flowIntensity = simState.flowIntensity; const flowTwist = simState.flowTwist;
             const totalSpeedMag = flowIntensity * MAX_FLOW_SPEED; // Base speed magnitude (rad/sec at intensity 1)
             const twistDenom = Math.sqrt(1.0 + flowTwist * flowTwist); const base_v_p = totalSpeedMag / twistDenom; // Base poloidal angular speed (rad/sec)
             const base_v_t = flowTwist * base_v_p; // Base toroidal angular speed (rad/sec)
             const flowCouple = simState.flowCouplingFactor; const angMomEffect = simState.angularMomentumEffect; const approxAngMom = simState.approximateAngularMomentum;
             const windingPhi = simState.windingPhi; // Winding speed (rad/sec)
             const windingTheta = simState.windingTheta; // Winding speed (rad/sec)
             const doSoliton = simState.solitonPhasing > 0; const solCoh = simState.solitonPhasing; const doJitter = simState.jitterScale > 0; const jitterScale = simState.jitterScale; const useDiscrete = simState.useDiscretePlacement && simState.discreteN > 0 && simState.discreteM > 0; const discreteN = simState.discreteN; const discreteM = simState.discreteM; const numGridPoints = useDiscrete ? discreteN * discreteM : 0; const stepN = useDiscrete ? twoPi / discreteN : 0; const stepM = useDiscrete ? twoPi / discreteM : 0; const doGridSnap = doSoliton && useDiscrete; const doEigenmode = simState.visualizeEigenmode && simState.eigenmodeFlowStrength !== 0; const eigenStr = simState.eigenmodeFlowStrength; const eigenM = simState.eigenmodeM; const eigenN = simState.eigenmodeN;
             const deltaInv = 1.0 / (delta + epsilon); // Used for velocity calculation from position diff
             const innerTorusRatio = simState.innerTorusRatio; const totalShells = simState.numInnerTori + 1; const approxParticlesPerShell = count > 0 ? Math.max(1, Math.floor(count / totalShells)) : 1;

             const doOpacityFromCam = simState.opacityFromCamera > 0; const doOpacityVariation = simState.particleOpacityVariation > 0; const baseOpacity = simState.particleOpacity;
             const maxDistanceForOpacity = initialCameraPosition.z * 1.5;

             for(let i = 0; i < count; i++) {
                 const idx = i * 3; const globalIdx = (particleOffset + i) * 3; const colorIdx = i * 4;
                 let shellIndex = Math.floor(i / approxParticlesPerShell); shellIndex = Math.min(shellIndex, totalShells - 1); const shellRatio = Math.pow(innerTorusRatio, shellIndex); let currentEffR = baseEffR * shellRatio; let currentEffr = baseEffr * shellRatio; if (Math.abs(currentEffR) <= Math.abs(currentEffr)) { currentEffR = (Math.sign(currentEffR) || 1) * (Math.abs(currentEffr) + epsilon); } currentEffR = Math.sign(currentEffR) * Math.max(epsilon, Math.abs(currentEffR)); currentEffr = Math.sign(currentEffr) * Math.max(epsilon, Math.abs(currentEffr));
                 const x_o=pos[idx]; const y_o=pos[idx+1]; const z_o=pos[idx+2];
                 const vx_prev = previousVelocities[globalIdx]; const vy_prev = previousVelocities[globalIdx + 1]; const vz_prev = previousVelocities[globalIdx + 2]; prevVelVec.set(vx_prev, vy_prev, vz_prev);
                 const rad_o=Math.sqrt(x_o*x_o+y_o*y_o); const a1_o=Math.atan2(y_o,x_o); const a2d_o = rad_o - currentEffR; const a2_o=Math.abs(a2d_o)<epsilon?(z_o>=0?Math.PI/2:-Math.PI/2):Math.atan2(z_o,a2d_o); const smFctr=Math.sin(a2_o); const signF = smFctr; const crxy_o = rad_o < epsilon ? epsilon : rad_o; let eigenmodeModulationFactor = 1.0;
                 if(doEigenmode) { const phase = (eigenM * a2_o + eigenN * a1_o); eigenmodeModulationFactor = 1.0 + eigenStr * Math.cos(phase); eigenmodeModulationFactor = eigenmodeModulationFactor < 0.1 ? 0.1 : eigenmodeModulationFactor; if (simState.colorMode === 'eigenmodePhase') needsDynamicRGBUpdate = true; }
                 const modulatedInwardSpeed = base_v_p * eigenmodeModulationFactor; // rad/sec
                 const modulatedRotationalSpeed = base_v_t * eigenmodeModulationFactor; // rad/sec
                 let effInwSpd = modulatedInwardSpeed; // rad/sec
                 let baseRotationalVelocityMagnitude; // rad/sec
                 if (approxAngMom) { const L_characteristic = Math.abs(modulatedRotationalSpeed * currentEffR); baseRotationalVelocityMagnitude = L_characteristic / crxy_o; }
                 else { let spdF = 1.0; if (angMomEffect > 0) { const bRfs = currentEffR < epsilon ? epsilon : currentEffR; spdF = 1 + angMomEffect * (bRfs / crxy_o - 1); spdF = spdF < 0.1 ? 0.1 : (spdF > (angMomEffect + 1.5) ? (angMomEffect + 1.5) : spdF); } baseRotationalVelocityMagnitude = modulatedRotationalSpeed * spdF; }
                 let baseRotSpd = signF * baseRotationalVelocityMagnitude; // rad/sec
                 if (flowCouple !== 0) { const normRotSpeed = Math.abs(baseRotationalVelocityMagnitude) / (base_v_t + epsilon); const couplingEffectOnInward = flowCouple * normRotSpeed; effInwSpd *= (1.0 + couplingEffectOnInward); }

                 // *** FIXED: Calculate angular step based on speed AND delta ***
                 let a1_step = baseRotSpd * delta; // radians = (rad/sec) * sec
                 let a2_step = effInwSpd * delta; // radians = (rad/sec) * sec

                 // Apply winding (also scaled by delta)
                 if(windingPhi !== 0) { a1_step += windingPhi * delta; } // radians += (rad/sec) * sec
                 if(windingTheta !== 0) { a2_step += windingTheta * delta; } // radians += (rad/sec) * sec

                 // Calculate new angles
                 let a1_base = a1_o + a1_step;
                 let a2_base = a2_o + a2_step;
                 // *** END FIX ***

                 const cosA2_base = Math.cos(a2_base); const sinA2_base = Math.sin(a2_base); const rFactor = currentEffR + currentEffr * cosA2_base; const x_base = rFactor * Math.cos(a1_base); const y_base = rFactor * Math.sin(a1_base); const z_base = currentEffr * sinA2_base; let final_x = x_base; let final_y = y_base; let final_z = z_base; if(doSoliton) { let target_x, target_y, target_z; if(doGridSnap && numGridPoints > 0) { const global_i = particleOffset + i; const target_gi = global_i % numGridPoints; const target_mi = target_gi % discreteM; const target_ni = Math.floor(target_gi / discreteM); const target_a1 = target_mi * stepM; const target_a2 = target_ni * stepN; const cos_a2_target = Math.cos(target_a2); const rFactor_target = currentEffR + currentEffr * cos_a2_target; target_x = rFactor_target * Math.cos(target_a1); target_y = rFactor_target * Math.sin(target_a1); target_z = currentEffr * Math.sin(target_a2); } else { target_x = x_base; target_y = y_base; target_z = z_base; } const devX = target_x - final_x; const devY = target_y - final_y; const devZ = target_z - final_z; final_x += devX * solCoh; final_y += devY * solCoh; final_z += devZ * solCoh; } let calc_x = final_x; let calc_y = final_y; let calc_z = final_z; if (doJitter) { calc_x += randomOffset(jitterScale); calc_y += randomOffset(jitterScale); calc_z += randomOffset(jitterScale); }
                 const render_x = calc_x; const render_y = calc_y; const render_z = calc_z; pos[idx] = render_x; pos[idx + 1] = render_y; pos[idx + 2] = render_z;
                 const dx = calc_x - x_o; const dy = calc_y - y_o; const dz = calc_z - z_o;
                 // Calculate velocity correctly using delta (time)
                 const vx_curr = dx * deltaInv; // vel = dist / time
                 const vy_curr = dy * deltaInv;
                 const vz_curr = dz * deltaInv;
                 currVelVec.set(vx_curr, vy_curr, vz_curr); previousVelocities[globalIdx] = vx_curr; previousVelocities[globalIdx + 1] = vy_curr; previousVelocities[globalIdx + 2] = vz_curr;

                 // --- Opacity Calculation ---
                 let currentAlpha = baseOpacity;
                 if (doOpacityVariation) { const variationAmount = Math.random() * simState.particleOpacityVariation; currentAlpha *= (1.0 - variationAmount); }
                 if (doOpacityFromCam) { tempVec3.set(render_x, render_y, render_z); mesh.localToWorld(tempVec3); const dist = tempVec3.distanceTo(camera.position); const distFactor = Math.min(1.0, dist / maxDistanceForOpacity); const opacityMultiplier = lerp(1.0, 0.0, distFactor * simState.opacityFromCamera); currentAlpha *= opacityMultiplier; }
                 currentAlpha = Math.max(0.0, Math.min(1.0, currentAlpha));

                 // --- Update Colors ---
                 if (needsDynamicRGBUpdate) { tempColor.setRGB(colors[colorIdx], colors[colorIdx + 1], colors[colorIdx + 2]); if (simState.colorMode === 'velocity') { const speed = currVelVec.length(); if (isFinite(speed)){ const ns = Math.min(1.0, speed / (MAX_EXPECTED_SPEED || 1)); tempColor.setHSL(0.66 - ns * 0.66, 1.0, 0.5); } else { tempColor.setRGB(1, 0, 1); } } else if (simState.colorMode === 'directionChange') { let normalizedAngle = 0; const prevLenSq = prevVelVec.lengthSq(); const currLenSq = currVelVec.lengthSq(); if (prevLenSq > epsilon && currLenSq > epsilon) { normPrev.copy(prevVelVec).normalize(); normCurr.copy(currVelVec).normalize(); const dot = normPrev.dot(normCurr); normalizedAngle = (1.0 - Math.max(-1.0, Math.min(1.0, dot))) * 0.5; } tempColor.setHSL(0.66 - normalizedAngle * 0.66, 1.0, 0.5); } else if (simState.colorMode === 'eigenmodePhase' && doEigenmode) { const final_a1 = Math.atan2(render_y, render_x); const final_rad = Math.sqrt(render_x*render_x + render_y*render_y); const final_a2_d = final_rad - currentEffR; const final_a2 = Math.abs(final_a2_d)<epsilon?(render_z>=0?Math.PI/2:-Math.PI/2):Math.atan2(render_z,final_a2_d); const phase = (eigenM * final_a2 + eigenN * final_a1); tempColor.setHSL((phase / twoPi + 1.0) % 1.0, 1.0, 0.5); } colors[colorIdx] = tempColor.r; colors[colorIdx + 1] = tempColor.g; colors[colorIdx + 2] = tempColor.b; }
                 colors[colorIdx + 3] = currentAlpha; // Write final Alpha
             }
             currentGeom.attributes.position.needsUpdate = true; colorAttribute.needsUpdate = true;
        }


        // --- UI Update Functions ---
        function updateDiscretePlacementControlsVisibility() { document.getElementById('discrete-placement-controls')?.classList.toggle('visible', simState.useDiscretePlacement); updateDiscretePointsDisplay(); }
        function updateEigenmodeControlsVisibility() { document.getElementById('eigenmode-controls')?.classList.toggle('visible', simState.visualizeEigenmode); }
        function updateManualColorControlsVisibility() { document.getElementById('manual-color-controls')?.classList.toggle('visible', simState.colorMode === 'manual'); }
        function updateDiscretePointsDisplay() { const totalPointsSpan = document.getElementById('discreteTotalPoints'); if (totalPointsSpan) { totalPointsSpan.textContent = (simState.useDiscretePlacement && simState.discreteN > 0 && simState.discreteM > 0) ? (simState.discreteN * simState.discreteM).toLocaleString() : 'N/A'; } }
        let fadeTimeoutId = null;
        function toggleUI(visible) { // Removed 'force' parameter
            const c = document.getElementById('controls');
            const sB = document.getElementById('showUIButton');
            const tB = document.getElementById('toggleUIButton');
            if (!c || !sB || !tB) return;

            clearTimeout(fadeTimeoutId);
            sB.classList.remove('faded-out');

            // REMOVED: Cinematic mode check

            simState.uiVisible = visible;
            if (visible) {
                c.style.opacity = '1';
                c.style.pointerEvents = 'auto';
                c.style.transform = 'translateX(0)';
                sB.classList.remove('visible');
                tB.textContent = 'Hide UI';
            } else {
                c.style.opacity = '0';
                c.style.pointerEvents = 'none';
                c.style.transform = 'translateX(-20px)';
                sB.classList.add('visible');
                tB.textContent = 'Show UI';
                // Start fade out timer for the "Show UI" button
                fadeTimeoutId = setTimeout(() => { sB.classList.add('faded-out'); }, 3000);
            }
        }

        function updateComposerPasses() { composer.passes = [renderPass]; if (simState.enableTrails && afterimagePass) { composer.addPass(afterimagePass); } if (simState.enableBloom && bloomPass) { composer.addPass(bloomPass); } console.log("Composer passes updated. Trails:", simState.enableTrails, "Bloom:", simState.enableBloom); }
        function toggleParticleCountSlider(enabled) {
            const slider = document.getElementById('particleCount');
            const label = document.getElementById('particleCountLabel');
            const numberInput = document.getElementById('particleCountNumber');

            if (slider) slider.disabled = !enabled;
            if (numberInput) numberInput.disabled = !enabled;
            if (label) label.classList.toggle('disabled', !enabled);
            if (label) label.style.cursor = enabled ? 'help' : 'not-allowed';

            // Opacity update now handled within updateControlValue for consistency
            updateControlValue('particleCount', simState.userParticleCount, controlsConfig.particleCount);
         }
        function syncParticleCountToGrid(triggerRebuild = false) { if (simState.useDiscretePlacement && simState.discreteN > 0 && simState.discreteM > 0) { const gridSize = simState.discreteN * simState.discreteM; let countChanged = simState.userParticleCount !== gridSize; if (countChanged) { simState.userParticleCount = gridSize; updateControlValue('particleCount', gridSize, controlsConfig.particleCount); } toggleParticleCountSlider(false); if (triggerRebuild && countChanged) { createParticleSystem(simState.userParticleCount); } } else { toggleParticleCountSlider(true); } }
        function updateDiscreteLinkIcon() { const icon = document.getElementById('discreteLinkIcon'); if (icon) { icon.classList.toggle('active', simState.discreteSlidersLinked); icon.textContent = simState.discreteSlidersLinked ? 'üîí' : 'üîó'; icon.title = simState.discreteSlidersLinked ? 'Unlink N and M sliders' : 'Link N and M sliders'; } }
        function toggleStats(visible) { simState.showStats = visible; if (statsContainer) { statsContainer.style.display = visible ? 'block' : 'none'; } }

        // --- Cinematic Camera Functions REMOVED ---
        // function startCinematicMode() { ... } // REMOVED
        // function stopCinematicMode() { ... } // REMOVED
        // function resetCinematicTimer() { ... } // REMOVED

        // Simplified interaction handler (only for UI fade)
        function handleInteraction() {
             // Reset fade out timer for the "Show UI" button if it's visible
            const sB = document.getElementById('showUIButton');
            if (sB && sB.classList.contains('visible') && !sB.classList.contains('faded-out')) {
                clearTimeout(fadeTimeoutId);
                 fadeTimeoutId = setTimeout(() => { sB.classList.add('faded-out'); }, 3000);
            }
        }


        // --- Animation Loop ---
        function animate() {
            if (simState.showStats) stats.begin();
            frameCount++; requestAnimationFrame(animate);
            const delta = clock.getDelta(); // Real time elapsed since last frame

            // Apply simulation speed multiplier to get simulation time step
            let simDelta = delta * simState.simSpeed;

            // Pause logic
            if (simState.isPaused) { simDelta = 0; }

            const elapsedTime = clock.getElapsedTime();

            // REMOVED: Cinematic mode check and activation logic

            let baseEffR = simState.torusRadius; let baseEffr = simState.tubeRadius; let pulseActive = simState.pulseAmplitude > 0 && simState.pulseFrequency > 0;
            if (pulseActive && !simState.isPaused) { // Only pulse if not paused
                const time = elapsedTime; const pf = simState.pulseAmplitude * Math.sin(time * simState.pulseFrequency * twoPi); baseEffR += pf; baseEffr += pf * 0.5; if (Math.abs(baseEffR) <= Math.abs(baseEffr)) { baseEffR = (Math.sign(baseEffR) || 1) * (Math.abs(baseEffr) + epsilon); } baseEffR = Math.sign(baseEffR) * Math.max(epsilon, Math.abs(baseEffR)); baseEffr = Math.sign(baseEffr) * Math.max(epsilon, Math.abs(baseEffr));
             }

            // Only update positions if simulation time has passed
            if (simDelta > 0) {
                 if (simState.arrangementMode === 'single') { const ps = scene.getObjectByName('particleSystem'); if (ps?.geometry) { updateParticlePositions(ps, ps.geometry, baseEffR, baseEffr, simDelta, 0); } } // Pass simDelta
                 else { let cumulativeOffset = 0; arrangementGroup.children.forEach(mesh => { if (mesh.geometry) { updateParticlePositions(mesh, mesh.geometry, baseEffR, baseEffr, simDelta, cumulativeOffset); cumulativeOffset += mesh.geometry.attributes.position.count; } }); } // Pass simDelta
                 // Update geometry only if pulsing and not paused
                 if (simState.showTorusGeometry && pulseActive && !simState.isPaused) { updateTorusGeometryMeshes(); }
            }

            // --- User-Controlled Camera Movement ---
            simState.cameraRotation.x = angleLerp(simState.cameraRotation.x, simState.targetCameraRotation.x, cameraTransitionSpeed);
            simState.cameraRotation.y = angleLerp(simState.cameraRotation.y, simState.targetCameraRotation.y, cameraTransitionSpeed);

            // Apply camera position and rotation
            const { x: rotX, y: rotY } = simState.cameraRotation;
            const camZDist = simState.cameraPosition.z;
            const camX = camZDist * Math.sin(rotY) * Math.cos(rotX);
            const camY = camZDist * Math.sin(rotX);
            const camZ = camZDist * Math.cos(rotY) * Math.cos(rotX);
            camera.position.set(camX, camY, camZ);
            camera.up.copy(worldUp);
            camera.lookAt(scene.position);

            composer.render(delta); // Render using the original delta for post-processing timing
            if (simState.showStats) stats.end();
        }


        // --- Control Configuration ---
        function getNumberInputProps(rangeElement) { if (!rangeElement) return {}; return { min: parseFloat(rangeElement.min), max: parseFloat(rangeElement.max), step: parseFloat(rangeElement.step) }; }
        const controlsConfig = {
            // Flow Dynamics
            flowIntensity:                 { stateVar: 'flowIntensity', type: 'range', numberId: 'flowIntensityNumber', format: v => v.toFixed(2) },
            flowTwist:                     { stateVar: 'flowTwist', type: 'range', numberId: 'flowTwistNumber', format: v => v.toFixed(1) },
            flowCouplingFactor:            { stateVar: 'flowCouplingFactor', type: 'range', numberId: 'flowCouplingFactorNumber', format: v => v.toFixed(2) },
            angularMomentumEffect:         { stateVar: 'angularMomentumEffect', type: 'range', numberId: 'angularMomentumEffectNumber', format: v => v.toFixed(2) },
            approximateAngularMomentum:    { stateVar: 'approximateAngularMomentum', type: 'checkbox', eventType: 'change' },
            windingTheta:                  { stateVar: 'windingTheta', type: 'range', numberId: 'windingThetaNumber', format: v => parseInt(v).toString() }, // Format as int string
            windingPhi:                    { stateVar: 'windingPhi', type: 'range', numberId: 'windingPhiNumber', format: v => parseInt(v).toString() }, // Format as int string
            solitonPhasing:                { stateVar: 'solitonPhasing', type: 'range', numberId: 'solitonPhasingNumber', format: v => v.toFixed(4) },
            jitterScale:                   { stateVar: 'jitterScale', type: 'range', numberId: 'jitterScaleNumber', format: v => v.toFixed(1) },
            visualizeEigenmode:            { stateVar: 'visualizeEigenmode', type: 'checkbox', eventType: 'change', effect: (v) => { updateEigenmodeControlsVisibility(); if(simState.colorMode === 'eigenmodePhase') {createParticleSystem(simState.userParticleCount); updateTorusGeometryMeshes();} } },
            eigenmodeM:                    { stateVar: 'eigenmodeM', type: 'number', eventType: 'input', effect: () => { if(simState.colorMode === 'eigenmodePhase' && simState.visualizeEigenmode) {createParticleSystem(simState.userParticleCount); updateTorusGeometryMeshes();} } },
            eigenmodeN:                    { stateVar: 'eigenmodeN', type: 'number', eventType: 'input', effect: () => { if(simState.colorMode === 'eigenmodePhase' && simState.visualizeEigenmode) {createParticleSystem(simState.userParticleCount); updateTorusGeometryMeshes();} } },
            eigenmodeFlowStrength:         { stateVar: 'eigenmodeFlowStrength', type: 'range', numberId: 'eigenmodeFlowStrengthNumber', format: v => v.toFixed(2) },
            // Geometry & Structure
            arrangementMode:               { stateVar: 'arrangementMode', type: 'select', eventType: 'change', changeEffect: (v) => { createParticleSystem(simState.userParticleCount); } },
            showTorusGeometry:             { stateVar: 'showTorusGeometry', type: 'checkbox', eventType: 'change', changeEffect: updateTorusGeometryMeshes },
            tubeRadius:                    { stateVar: 'tubeRadius', type: 'range', numberId: 'tubeRadiusNumber', format: v => parseInt(v).toString(), eventType: 'input', changeEffect: (v, debounce) => { debounce(() => {createParticleSystem(simState.userParticleCount);}, 300)(); } },
            torusRadius:                   { stateVar: 'torusRadius', type: 'range', numberId: 'torusRadiusNumber', format: v => parseInt(v).toString(), eventType: 'input', changeEffect: (v, debounce) => { debounce(() => {createParticleSystem(simState.userParticleCount);}, 300)(); } },
            pulseAmplitude:                { stateVar: 'pulseAmplitude', type: 'range', numberId: 'pulseAmplitudeNumber', format: v => parseInt(v).toString(), changeEffect: (v, debounce) => { debounce(updateTorusGeometryMeshes, 50)(); } },
            pulseFrequency:                { stateVar: 'pulseFrequency', type: 'range', numberId: 'pulseFrequencyNumber', format: v => v.toFixed(2), changeEffect: (v, debounce) => { debounce(updateTorusGeometryMeshes, 50)(); } },
            numInnerTori:                  { stateVar: 'numInnerTori', type: 'range', numberId: 'numInnerToriNumber', format: v => parseInt(v).toString(), eventType: 'input', changeEffect: (v, debounce) => { debounce(() => {createParticleSystem(simState.userParticleCount);}, 300)(); } },
            innerTorusRatio:               { stateVar: 'innerTorusRatio', type: 'range', numberId: 'innerTorusRatioNumber', format: v => v.toFixed(2), eventType: 'input', changeEffect: (v, debounce) => { debounce(() => {createParticleSystem(simState.userParticleCount);}, 300)(); } },
            useDiscretePlacement:          { stateVar: 'useDiscretePlacement', type: 'checkbox', eventType: 'change', changeEffect: (isChecked) => { updateDiscretePlacementControlsVisibility(); toggleParticleCountSlider(!isChecked); syncParticleCountToGrid(true); }},
            discreteN:                     { stateVar: 'discreteN', type: 'range', numberId: 'discreteNNumber', format: v => parseInt(v).toString(), effect: updateDiscretePointsDisplay, eventType: 'input', changeEffect: (v, debounce) => { if(simState.useDiscretePlacement) syncParticleCountToGrid(true); } },
            discreteM:                     { stateVar: 'discreteM', type: 'range', numberId: 'discreteMNumber', format: v => parseInt(v).toString(), effect: updateDiscretePointsDisplay, eventType: 'input', changeEffect: (v, debounce) => { if(simState.useDiscretePlacement) syncParticleCountToGrid(true); } },
            // Particles & Appearance
            particleCount:                 { stateVar: 'userParticleCount', type: 'range', numberId: 'particleCountNumber', format: v => (v/1000).toFixed(0), /* Format for 'k' display */ eventType: 'input', changeEffect: (v, debounce) => { if (!simState.useDiscretePlacement) { debounce(() => {createParticleSystem(v);}, 300)(); } } },
            particleSize:                  { stateVar: 'particleSize', type: 'range', numberId: 'particleSizeNumber', format: v => v.toFixed(1), effect: (v) => { if(particlesMaterial) particlesMaterial.size = v; } },
            energyIntensity:               { stateVar: 'energyIntensity', type: 'range', numberId: 'energyIntensityNumber', format: v => parseInt(v).toString(), effect: (v) => { if(particlesMaterial) particlesMaterial.needsUpdate = true; /* Might affect bloom? */ } }, // Added effect
            particleOpacity:               { stateVar: 'particleOpacity', type: 'range', numberId: 'particleOpacityNumber', format: v => v.toFixed(2) },
            particleOpacityVariation:      { stateVar: 'particleOpacityVariation', type: 'range', numberId: 'particleOpacityVariationNumber', format: v => v.toFixed(2) },
            opacityFromCamera:             { stateVar: 'opacityFromCamera', type: 'range', numberId: 'opacityFromCameraNumber', format: v => v.toFixed(2) },
            colorMode:                     { stateVar: 'colorMode', type: 'select', eventType: 'change', changeEffect: () => { updateManualColorControlsVisibility(); createParticleSystem(simState.userParticleCount); } },
            particleColorR:                { stateVar: 'particleColorR', type: 'range', numberId: 'particleColorRNumber', format: v => v.toFixed(2), changeEffect: (v, debounce) => { if(simState.colorMode === 'manual') { debounce(() => {createParticleSystem(simState.userParticleCount);}, 300)(); } } },
            particleColorG:                { stateVar: 'particleColorG', type: 'range', numberId: 'particleColorGNumber', format: v => v.toFixed(2), changeEffect: (v, debounce) => { if(simState.colorMode === 'manual') { debounce(() => {createParticleSystem(simState.userParticleCount);}, 300)(); } } },
            particleColorB:                { stateVar: 'particleColorB', type: 'range', numberId: 'particleColorBNumber', format: v => v.toFixed(2), changeEffect: (v, debounce) => { if(simState.colorMode === 'manual') { debounce(() => {createParticleSystem(simState.userParticleCount);}, 300)(); } } },
            particleColorVariation:        { stateVar: 'particleColorVariation', type: 'range', numberId: 'particleColorVariationNumber', format: v => v.toFixed(2), changeEffect: (v, debounce) => { if(simState.colorMode === 'manual') { debounce(() => {createParticleSystem(simState.userParticleCount);}, 300)(); } } },
            // Post-Processing
            enableTrails:                  { stateVar: 'enableTrails', type: 'checkbox', eventType: 'change', effect: updateComposerPasses },
            trailDecay:                    { stateVar: 'trailDecay', type: 'range', numberId: 'trailDecayNumber', format: v => v.toFixed(3), effect: (v) => { if(afterimagePass) afterimagePass.uniforms["damp"].value = v; } },
            enableBloom:                   { stateVar: 'enableBloom', type: 'checkbox', eventType: 'change', effect: updateComposerPasses },
            // Animation
            simSpeed:                      { stateVar: 'simSpeed', type: 'range', numberId: 'simSpeedNumber', format: v => v.toFixed(1) /* Format for number display */ },
        };


        // --- Helper to set state value ---
        function setStateValue(stateVar, value, type) {
             if (type === 'range' || type === 'number' || type === 'number-input') {
                 const num = parseFloat(value); simState[stateVar] = isNaN(num) ? simState[stateVar] : num;
             } else if (type === 'checkbox') { simState[stateVar] = !!value; } else { simState[stateVar] = value; }
             // Ensure integer types remain integers (excluding userParticleCount which can be float during input)
             if (['windingTheta', 'windingPhi', 'discreteN', 'discreteM', 'eigenmodeM', 'eigenmodeN', 'numInnerTori', 'energyIntensity', 'tubeRadius', 'torusRadius', 'pulseAmplitude'].includes(stateVar)) {
                const parsedInt = parseInt(simState[stateVar]);
                simState[stateVar] = isNaN(parsedInt) ? 0 : parsedInt; // Default to 0 if parsing fails
             }
             // Ensure discrete N/M have minimum value
             if (stateVar === 'discreteN' || stateVar === 'discreteM') { simState[stateVar] = Math.max(4, parseInt(simState[stateVar]) || 4); }
             // Ensure simSpeed has a minimum value
             if (stateVar === 'simSpeed') { simState[stateVar] = Math.max(0.01, parseFloat(simState[stateVar]) || 0.1); } // Ensure speed doesn't go to 0 or negative
        }

        // --- Helper to update control value (Revised) ---
        function updateControlValue(id, value, config) {
            const element = document.getElementById(id); if (!element || !config) return;
            const isCheckbox = config.type === 'checkbox'; const isSlider = config.type === 'range'; const isSelect = config.type === 'select'; const isTextInput = config.type === 'text'; const isNumberInputOnly = config.type === 'number'; // For non-slider number inputs like eigenmode M/N
            let numValue = parseFloat(value);

            // Update the primary element (slider, checkbox, select, etc.)
            if (isCheckbox) { element.checked = !!value; }
            else { if (!isNaN(numValue)) { element.value = numValue; } else if (isSelect || isTextInput) { element.value = value; } else if (isNumberInputOnly) { element.value = value; } } // Allow direct value for number-only inputs

            // Find associated elements (label, number input, unit span)
            const parentContainer = element.closest('.slider-container, .animation-controls, .input-container'); // Find container
            const label = parentContainer?.querySelector('label[for="' + id + '"]');
            const numberInput = config.numberId ? document.getElementById(config.numberId) : null;
            const unitSpan = numberInput?.nextElementSibling; // Get potential unit span next to number input

            // Update associated number input if it exists
            if (numberInput && (isSlider || isNumberInputOnly || id === config.numberId || id === 'simSpeed' || id === 'simSpeedNumber')) { // Explicitly include simSpeed
                let valueToFormat = parseFloat(simState[config.stateVar]); // Get the definitive state value

                 // Special handling for particleCount display ('k')
                 if (config.stateVar === 'userParticleCount') {
                     valueToFormat /= 1000; // Convert to 'k' for display format
                 }

                if (!isNaN(valueToFormat) && config.format) {
                    const formattedValueString = config.format(valueToFormat); // Format the value (e.g., toFixed)

                    // Determine display decimals based on the *number* input's step attribute
                    const numStep = parseFloat(numberInput.step) || 0.01;
                    const decimals = Math.max(0, (numStep.toString().split('.')[1] || '').length);

                    // Use the formatted string, but ensure it respects the number input's precision
                    // Re-parse the formatted string to handle potential rounding from format()
                    let finalDisplayValue = parseFloat(formattedValueString);
                    if (!isNaN(finalDisplayValue)) {
                         numberInput.value = finalDisplayValue.toFixed(decimals);
                    } else {
                         // Fallback if formatting/parsing fails, show original value formatted
                         numberInput.value = parseFloat(value).toFixed(decimals);
                    }
                } else {
                     // Fallback if formatting not possible or not defined
                     const primaryElement = isSlider ? element : document.getElementById(id.replace('Number',''));
                     const sliderStep = primaryElement ? parseFloat(primaryElement.step) : 0.01;
                     const fallbackDecimals = (sliderStep.toString().split('.')[1] || '').length;
                     numberInput.value = isNaN(numValue) ? '' : numValue.toFixed(fallbackDecimals);
                }
            }

             // Update disabled appearance for label, number input, and span
             const primaryElement = document.getElementById(id); // The element this function was called for
             const isDisabled = primaryElement ? primaryElement.disabled : false;

             if (label) {
                 label.style.opacity = isDisabled ? '0.5' : '1';
                 label.style.cursor = isDisabled ? 'not-allowed' : 'help';
             }
             if(numberInput) {
                 numberInput.style.opacity = isDisabled ? '0.5' : '1';
             }
             if (unitSpan && unitSpan.tagName === 'SPAN') { // Check it's the span
                  unitSpan.style.opacity = isDisabled ? '0.5' : '1';
             }
             // Special case for checkbox label
             if (isCheckbox) {
                const checkboxLabel = element.nextElementSibling;
                if (checkboxLabel && checkboxLabel.tagName === 'LABEL') {
                     checkboxLabel.style.opacity = isDisabled ? '0.5' : '1';
                     checkboxLabel.style.cursor = isDisabled ? 'not-allowed' : 'pointer'; // Use pointer for checkbox label
                }
             }
        }


        // --- initializeUI ---
        function initializeUI() {
            console.log(`Initializing UI from simState (v${localStorageKeyPrefix.split('_v')[1]}...`);
            for (const id in controlsConfig) { const config = controlsConfig[id]; if (simState.hasOwnProperty(config.stateVar)) { updateControlValue(id, simState[config.stateVar], config); } else { console.warn(`State variable '${config.stateVar}' not found for control '${id}'.`); } }
            updateDiscretePlacementControlsVisibility(); updateEigenmodeControlsVisibility(); updateManualColorControlsVisibility(); updateDiscretePointsDisplay(); updateComposerPasses(); updateDiscreteLinkIcon();
            document.getElementById('playPauseButton').textContent = simState.isPaused ? 'Play' : 'Pause';
            toggleUI(simState.uiVisible); // Use simplified toggleUI
            toggleStats(simState.showStats); updateTorusGeometryMeshes(); toggleParticleCountSlider(!simState.useDiscretePlacement);
            document.querySelectorAll('.control-section').forEach((details, index) => { details.open = (index === 0); });
        }


        // --- DOM Ready ---
        document.addEventListener('DOMContentLoaded', function() {

             // Define debounced functions here
             const debouncedUpdateTorusGeometry = debounce(updateTorusGeometryMeshes, 300);
             const numberInputDebounceWait = 350; // Debounce time for number input change effects

            // --- Named Config Slot Functions ---
             const configNameInput = document.getElementById('configNameInput'); const configSelect = document.getElementById('configSelect');
             function getConfigSlotKey(name) { const sanitizedName = name.replace(/[^\w\s-]/g, '').trim(); return sanitizedName ? namedSlotPrefix + sanitizedName : null; }
             function populateConfigDropdown() { configSelect.innerHTML = '<option value="">-- Select Saved Config --</option>'; let savedConfigs = []; for (let i = 0; i < localStorage.length; i++) { const key = localStorage.key(i); if (key.startsWith(namedSlotPrefix)) { savedConfigs.push(key.substring(namedSlotPrefix.length)); } } savedConfigs.sort((a, b) => a.localeCompare(b)); savedConfigs.forEach(name => { const option = document.createElement('option'); option.value = name; option.textContent = name; configSelect.appendChild(option); }); }
             function saveNamedConfig() { handleInteraction(); const name = configNameInput.value.trim(); if (!name) { alert("Please enter a name."); configNameInput.focus(); return; } const key = getConfigSlotKey(name); if (!key) { alert("Invalid name."); return; } try { const stateToSave = {}; for (const id in controlsConfig) { const config = controlsConfig[id]; if (simState.hasOwnProperty(config.stateVar)) { stateToSave[config.stateVar] = simState[config.stateVar]; } } stateToSave.cameraPosition = { ...simState.cameraPosition }; stateToSave.cameraRotation = { ...simState.cameraRotation }; stateToSave.discreteSlidersLinked = simState.discreteSlidersLinked; stateToSave.showStats = simState.showStats; localStorage.setItem(key, JSON.stringify(stateToSave)); console.log(`Config saved: ${name}`); alert(`'${name}' saved!`); populateConfigDropdown(); configSelect.value = name; configNameInput.value = ''; } catch (error) { console.error(`Save failed '${name}':`, error); alert(`Error saving '${name}'.`); } }
             function loadNamedConfig() { handleInteraction(); const name = configSelect.value; if (!name) { alert("Select config."); return; } const key = getConfigSlotKey(name); if (!key) return; const loadedOk = loadStateFromStorage(key, `config '${name}'`); if(loadedOk) { initializeUI(); syncParticleCountToGrid(false); createParticleSystem(simState.userParticleCount); updateTorusGeometryMeshes(); alert(`'${name}' loaded.`); } }
             function deleteNamedConfig() { handleInteraction(); const name = configSelect.value; if (!name) { alert("Select config."); return; } const key = getConfigSlotKey(name); if (!key) return; if (confirm(`Delete config '${name}'?`)) { try { localStorage.removeItem(key); console.log(`Deleted: ${name}`); alert(`'${name}' deleted.`); populateConfigDropdown(); } catch (error) { console.error(`Delete failed '${name}':`, error); alert(`Error deleting '${name}'.`); } } }

            // --- Auto Save/Load State ---
            function autoSaveState() { try { const stateToSave = {}; for (const id in controlsConfig) { const config = controlsConfig[id]; if (simState.hasOwnProperty(config.stateVar)) { stateToSave[config.stateVar] = simState[config.stateVar]; } } stateToSave.cameraPosition = { ...simState.cameraPosition }; stateToSave.cameraRotation = { ...simState.cameraRotation }; stateToSave.discreteSlidersLinked = simState.discreteSlidersLinked; stateToSave.showStats = simState.showStats; localStorage.setItem(autoSaveKey, JSON.stringify(stateToSave)); } catch (error) { console.error("Auto-save failed:", error); } } const debouncedAutoSave = debounce(autoSaveState, 750);
            function loadStateFromStorage(storageKey, sourceDescription = "saved state") {
                const savedState = localStorage.getItem(storageKey);
                if (savedState) {
                    try {
                        const state = JSON.parse(savedState);
                        console.log(`Loading ${sourceDescription}...`);
                        // Create a clean default state for merging (Cinematic properties removed here too)
                         const defaultStateCopy = JSON.parse(JSON.stringify( {
                            flowIntensity: 0.5, flowTwist: 2.0, flowCouplingFactor: 0.0,
                            angularMomentumEffect: 5.0, approximateAngularMomentum: true,
                            windingTheta: 0, windingPhi: 0, solitonPhasing: 0.0,
                            jitterScale: 0.0, visualizeEigenmode: false, eigenmodeM: 1, eigenmodeN: 2, eigenmodeFlowStrength: 0.0,
                            arrangementMode: 'single', tubeRadius: 2940, torusRadius: 3000, pulseAmplitude: 0.0, pulseFrequency: 0.5,
                            numInnerTori: 0, innerTorusRatio: 0.5, useDiscretePlacement: true, discreteN: 300, discreteM: 300,
                            discreteSlidersLinked: true, showTorusGeometry: false,
                            userParticleCount: 90000, particleCount: 90000, particleSize: 1.0, energyIntensity: 50.0,
                            particleOpacity: 0.8, particleOpacityVariation: 0.0, opacityFromCamera: 0.0,
                            colorMode: 'manual', particleColorR: 0.39, particleColorG: 0.62, particleColorB: 1.00, particleColorVariation: 1.0,
                            enableTrails: true, trailDecay: 0.938, enableBloom: true,
                            isPaused: false, simSpeed: 1.0, uiVisible: true, showStats: false,
                            cameraPosition: { ...initialCameraPosition }, cameraRotation: { ...initialCameraRotation },
                            targetCameraRotation: { ...initialCameraRotation }
                        } ));
                        const mergedState = { ...defaultStateCopy };
                        for (const key in defaultStateCopy) {
                             if (state.hasOwnProperty(key) && key !== 'targetCameraRotation') { // Don't load target rotation
                                if (key === 'cameraPosition' || key === 'cameraRotation') {
                                     if(typeof state[key] === 'object' && state[key] !== null){ mergedState[key] = { ...mergedState[key], ...state[key] }; }
                                } else if (typeof defaultStateCopy[key] === 'boolean') { mergedState[key] = !!state[key]; }
                                else if (typeof defaultStateCopy[key] === 'number') { const parsedNum = parseFloat(state[key]); if (!isNaN(parsedNum)) { mergedState[key] = parsedNum; } }
                                else { mergedState[key] = state[key]; }
                            }
                        }
                        // Explicitly copy over potentially missing bools/specific keys if needed (handled by loop now)
                        if (state.hasOwnProperty('discreteSlidersLinked')) { mergedState.discreteSlidersLinked = !!state.discreteSlidersLinked; }
                        if (state.hasOwnProperty('showStats')) { mergedState.showStats = !!state.showStats; }

                        simState = mergedState;
                        simState.targetCameraRotation = { ...simState.cameraRotation }; // Set target rot based on loaded rot
                        console.log(`${sourceDescription} loaded.`);
                        return true;
                    } catch (error) {
                        console.error(`Load failed ${sourceDescription}:`, error);
                        if (storageKey === autoSaveKey) { localStorage.removeItem(storageKey); alert(`Error loading ${sourceDescription}. Cleared auto-save.`); }
                        else { alert(`Error loading ${sourceDescription}. Please check console.`); }
                        return false;
                    }
                } else {
                    console.log(`No ${sourceDescription} found.`);
                    return false;
                }
             }


            // --- Reinitiate Simulation Function ---
            function reinitiateSimulation() {
                 handleInteraction(); // Treat as interaction
                 console.log("Reinitiating simulation (particles only)...");
                 createParticleSystem(simState.userParticleCount);
                 updateTorusGeometryMeshes();
                 console.log("Simulation reinitiated.");
             } // Non-debounced

            // --- Initial Load & Setup ---
            loadStateFromStorage(autoSaveKey, "auto-saved state");
            populateConfigDropdown();
            initializeUI();
            syncParticleCountToGrid(false);
            createParticleSystem(simState.userParticleCount);
            updateTorusGeometryMeshes();
            // REMOVED: resetCinematicTimer();


            // --- Global Event Listeners ---
            window.addEventListener('resize', () => { handleInteraction(); const w=window.innerWidth,h=window.innerHeight;camera.aspect=w/h;camera.updateProjectionMatrix();renderer.setSize(w,h);composer.setSize(w,h); bloomPass.setSize(w, h); });
            document.addEventListener('mousedown', (e)=>{ handleInteraction(); if(!e.target.closest('#controls')){isDragging=true;previousMousePosition={x:e.clientX,y:e.clientY};}}); // Allow drag outside controls
            document.addEventListener('mouseup',()=>{ handleInteraction(); isDragging=false; }); // Always stop drag on mouseup
            document.addEventListener('mousemove', (e)=>{ if(isDragging){ handleInteraction(); const dM={x:e.clientX-previousMousePosition.x,y:e.clientY-previousMousePosition.y}; simState.targetCameraRotation.y+=dM.x*0.005; simState.targetCameraRotation.x+=dM.y*0.005; simState.targetCameraRotation.x = Math.max(-Math.PI / 2 + epsilon, Math.min(Math.PI / 2 - epsilon, simState.targetCameraRotation.x)); previousMousePosition={x:e.clientX,y:e.clientY}; debouncedAutoSave(); } else { handleInteraction(); } }); // Handle passive move too
            document.addEventListener('wheel',(e)=>{ handleInteraction(); if (!e.target.closest('#controls')) { const zS = 0.1 * (simState.cameraPosition.z / 1000); const d = -Math.sign(e.deltaY) * zS; simState.cameraPosition.z = Math.max(1000, Math.min(100000, simState.cameraPosition.z - d * 500)); e.preventDefault(); debouncedAutoSave(); }}, {passive:false});
            document.addEventListener('touchstart', handleInteraction, { passive: true }); // Handle touch interaction
            document.addEventListener('touchmove', handleInteraction, { passive: true }); // Handle touch interaction

            // --- Control Panel Event Delegation ---
            const controlsDiv = document.getElementById('controls');

            // Shared handler for input events (range and number)
            const handleInputChange = (e) => {
                handleInteraction(); // UI input is interaction
                const target = e.target;
                const id = target.id;
                let config = controlsConfig[id];
                let isNumberInput = target.type === 'number' && target.classList.contains('slider-number-input');
                let baseId = id; // ID of the primary control (usually the range slider)

                if (isNumberInput) { baseId = id.replace('Number', ''); config = controlsConfig[baseId]; }
                else if (target.type === 'number' && controlsConfig[id]) { // Handle standalone number inputs
                    config = controlsConfig[id];
                    baseId = id; // It is its own base
                }

                if (!config || !config.stateVar) {
                    // console.warn("No config found for:", id);
                    return; // Exit if no valid config found
                }

                const type = config.type;
                let value = target.value;
                let processedValue = value; // Start with raw value

                // Process and Validate Value for Range/Number Types
                 if (type === 'range' || type === 'number' || isNumberInput) {
                    const rangeElement = document.getElementById(baseId); // Use baseId to find the defining element (often the slider)
                    const numberInputElement = config.numberId ? document.getElementById(config.numberId) : (type === 'number' ? target : null); // Get the number input element if applicable

                    const props = getNumberInputProps(rangeElement); // Get min/max/step from the slider/primary element
                    let numVal = parseFloat(value);

                    if (!isNaN(numVal)) {
                         // Specific Scaling for Particle Count Number Input (handles 'k')
                         if (config.stateVar === 'userParticleCount' && (isNumberInput || target.id === 'particleCountNumber')) {
                             numVal *= 1000; // Scale from 'k' to actual count
                         }

                        // Apply Clamping based on the *primary control's* limits (usually the range slider)
                        numVal = Math.min(props.max ?? Infinity, Math.max(props.min ?? -Infinity, numVal));

                        // Apply Step Rounding based on the *primary control's* step
                         if (props.step && props.step > 0) {
                           // Avoid floating point issues with rounding
                           const invStep = 1.0 / props.step;
                           numVal = Math.round(numVal * invStep) / invStep;
                         }

                        processedValue = numVal; // Final numeric value for state
                    } else {
                        // If parsing failed, revert to current state value (or default?)
                        processedValue = simState[config.stateVar];
                        console.warn("Input parse failed for", id, "value:", value, "Reverting to:", processedValue);
                    }
                } else if (type === 'checkbox') {
                     processedValue = target.checked;
                }
                // else: Select or Text input (processedValue remains the raw string value)


                // Update State
                setStateValue(config.stateVar, processedValue, config.type); // Use config.type here

                // Update UI (Sync slider and number input) - Update based on the *final state value*
                updateControlValue(baseId, simState[config.stateVar], config);

                // Handle Linked Sliders (N/M)
                if (simState.discreteSlidersLinked && (baseId === 'discreteN' || baseId === 'discreteM')) {
                     const linkedIdBase = (baseId === 'discreteN') ? 'discreteM' : 'discreteN';
                     const linkedConfig = controlsConfig[linkedIdBase];
                     const linkedRange = document.getElementById(linkedIdBase);
                     if (linkedRange && linkedConfig) {
                         const linkedProps = getNumberInputProps(linkedRange);
                          // Use the value from the state (which was just updated) as the target for the linked one
                         let targetValue = parseFloat(simState[config.stateVar]) || 0;
                         targetValue = Math.max(linkedProps.min ?? 0, Math.min(linkedProps.max ?? Infinity, targetValue));
                          // Apply step rounding for the *linked* slider
                          if (linkedProps.step && linkedProps.step > 0) {
                             const invStep = 1.0 / linkedProps.step;
                             targetValue = Math.round(targetValue * invStep) / invStep;
                         }
                         targetValue = Math.max(linkedProps.min ?? 0, Math.min(linkedProps.max ?? Infinity, targetValue)); // Re-clamp after step

                         // Only update if the value actually changes to prevent infinite loops
                         if (targetValue !== simState[linkedConfig.stateVar]){
                            setStateValue(linkedConfig.stateVar, targetValue, linkedConfig.type);
                            updateControlValue(linkedIdBase, targetValue, linkedConfig);
                         }
                     }
                 }

                // Trigger Effects & Save
                if (config.effect) { config.effect(simState[config.stateVar]); }
                if (config.changeEffect) {
                     // Use debounce for change effects, especially those triggering rebuilds
                     const effectDebounceTime = config.changeEffect ? (isNumberInput ? numberInputDebounceWait : 300) : 0;
                     debounce(() => {
                         config.changeEffect(simState[config.stateVar], debounce); // Pass debounce if needed by effect
                         debouncedAutoSave(); // Save after potentially heavy change effect completes
                     }, effectDebounceTime)();
                } else {
                    // If no heavy change effect, save state with standard debounce
                    debouncedAutoSave();
                }
            };


            controlsDiv.addEventListener('input', handleInputChange); // Handles range sliders and direct number input typing
            controlsDiv.addEventListener('change', (e) => { // Handles checkbox, select, and finalizing number input
                 handleInteraction(); // UI input is interaction
                 const target = e.target;
                 const id = target.id;

                // Check if it's a number input that needs final processing on change (e.g., user typed and tabbed away)
                 if (target.type === 'number') {
                     // Re-trigger handleInputChange on 'change' for number inputs
                     // This catches final value after focus loss or pressing Enter, ensuring validation/clamping
                     handleInputChange(e);
                 }
                 // Handle checkboxes and select dropdowns
                 else if (target.type === 'checkbox' || target.tagName === 'SELECT') {
                    const config = controlsConfig[id];
                    if (!config || !config.stateVar) return;
                    const value = (target.type === 'checkbox') ? target.checked : target.value;
                    setStateValue(config.stateVar, value, config.type);
                    updateControlValue(id, simState[config.stateVar], config);
                    if (config.effect) { config.effect(simState[config.stateVar]); }
                    if (config.changeEffect) { config.changeEffect(simState[config.stateVar], debounce); }
                    debouncedAutoSave();
                 }
            });


            // --- Button Event Listeners ---
            document.getElementById('toggleUIButton').addEventListener('click', ()=>{ handleInteraction(); toggleUI(!simState.uiVisible); debouncedAutoSave(); });
            const showUIButton = document.getElementById('showUIButton'); showUIButton?.addEventListener('click', ()=>{ handleInteraction(); toggleUI(true); debouncedAutoSave(); }); showUIButton?.addEventListener('mouseenter', () => { clearTimeout(fadeTimeoutId); showUIButton.classList.remove('faded-out'); }); showUIButton?.addEventListener('mouseleave', () => { if (!simState.uiVisible) { clearTimeout(fadeTimeoutId); fadeTimeoutId = setTimeout(() => { showUIButton.classList.add('faded-out'); }, 3000); } });
            document.getElementById('playPauseButton').addEventListener('click', () => { handleInteraction(); simState.isPaused = !simState.isPaused; document.getElementById('playPauseButton').textContent = simState.isPaused ? 'Play' : 'Pause'; debouncedAutoSave(); });
            document.getElementById('reinitiateButton').addEventListener('click', reinitiateSimulation); // Already handles interaction
            document.getElementById('resetPresetButton').addEventListener('click', () => { handleInteraction(); if (confirm("Reset all settings to default AND clear auto-save and ALL named configurations?")) { localStorage.removeItem(autoSaveKey); for (let i = localStorage.length - 1; i >= 0; i--) { const key = localStorage.key(i); if (key.startsWith(namedSlotPrefix)) { localStorage.removeItem(key); } } window.location.reload(); } });
            document.getElementById('saveConfigButton').addEventListener('click', saveNamedConfig); // Already handles interaction
            document.getElementById('loadConfigButton').addEventListener('click', loadNamedConfig); // Already handles interaction
            document.getElementById('deleteConfigButton').addEventListener('click', deleteNamedConfig); // Already handles interaction
            document.getElementById('discreteLinkIcon').addEventListener('click', () => { handleInteraction(); simState.discreteSlidersLinked = !simState.discreteSlidersLinked; updateDiscreteLinkIcon(); if (simState.discreteSlidersLinked) { const nValue = simState.discreteN; const mSlider = document.getElementById('discreteM'); if (mSlider) { const mConfig = controlsConfig.discreteM; const mProps = getNumberInputProps(mSlider); let targetValue = Math.max(mProps.min ?? 4, Math.min(mProps.max ?? Infinity, nValue)); if (mProps.step && mProps.step > 0) { const invStep = 1.0 / mProps.step; targetValue = Math.round(targetValue * invStep) / invStep; } targetValue = Math.max(mProps.min ?? 4, Math.min(mProps.max ?? Infinity, targetValue)); if (targetValue !== simState.discreteM) { setStateValue('discreteM', targetValue, mConfig.type); updateControlValue('discreteM', targetValue, mConfig); if (simState.useDiscretePlacement) { syncParticleCountToGrid(true); } } } } debouncedAutoSave(); });
            document.getElementById('toggleStatsButton')?.addEventListener('click', () => { handleInteraction(); toggleStats(!simState.showStats); debouncedAutoSave(); });
            const isoAngleX = Math.atan(1/Math.sqrt(2)); const isoAngleY = Math.PI / 4; const viewButtons = { 'snapTopViewButton': { x: Math.PI / 2 - epsilon, y: 0 }, 'snapBottomViewButton': { x: -Math.PI / 2 + epsilon, y: 0 }, 'snapFrontViewButton': { x: 0, y: 0 }, 'snapBackViewButton': { x: 0, y: Math.PI }, 'snapLeftViewButton': { x: 0, y: -Math.PI / 2 }, 'snapRightViewButton': { x: 0, y: Math.PI / 2 }, 'snapIsoNEButton': { x: isoAngleX, y: -isoAngleY }, 'snapIsoNWButton': { x: isoAngleX, y: isoAngleY }, 'snapIsoSEButton': { x: isoAngleX, y: -isoAngleY + Math.PI }, 'snapIsoSWButton': { x: isoAngleX, y: isoAngleY + Math.PI }, }; for (const btnId in viewButtons) { document.getElementById(btnId)?.addEventListener('click', () => { handleInteraction(); simState.targetCameraRotation = { ...viewButtons[btnId] }; debouncedAutoSave(); }); }

            // --- Hotkeys Setup ---
            const hotkeysPanel = document.getElementById('hotkeysPanel'); document.getElementById('showHotkeysButton')?.addEventListener('click', () => { handleInteraction(); hotkeysPanel.style.display = 'block'; }); document.getElementById('closeHotkeysButton')?.addEventListener('click', () => { handleInteraction(); hotkeysPanel.style.display = 'none'; }); hotkeysPanel?.addEventListener('keydown', (e) => { handleInteraction(); if (e.key === 'Escape') { hotkeysPanel.style.display = 'none'; } });
            document.addEventListener('keydown', (e) => {
                handleInteraction(); // Any key press is interaction
                const targetTagName = e.target.tagName;
                const isInputFocused = targetTagName === 'INPUT' || targetTagName === 'SELECT' || targetTagName === 'TEXTAREA';
                const isHotkeysPanelOpen = hotkeysPanel?.style.display === 'block';
                if (isHotkeysPanelOpen && e.key !== 'Escape') return;
                if (isInputFocused && e.key !== 'Escape') return; // Allow Esc to blur focus

                let handled = true; let buttonToClick = null;
                 switch (e.key) {
                     case ' ': buttonToClick = 'playPauseButton'; break;
                     case 'h': case 'H': buttonToClick = 'toggleUIButton'; break;
                     case 'R': if (e.shiftKey) { buttonToClick = 'reinitiateButton'; } else { handled = false; } break;
                     case 'Delete': if (e.shiftKey) { buttonToClick = 'resetPresetButton'; } else { handled = false; } break;
                     case 't': case 'T': buttonToClick = 'snapTopViewButton'; break;
                     case 'f': case 'F': buttonToClick = 'snapFrontViewButton'; break;
                     case 'l': case 'L': buttonToClick = 'snapLeftViewButton'; break;
                     case 'i': case 'I': buttonToClick = 'snapIsoNEButton'; break;
                     case 'Escape':
                         if (isHotkeysPanelOpen) { hotkeysPanel.style.display = 'none'; }
                         else if(isInputFocused) { e.target.blur(); } // Blur focused input on Escape
                         else { handled = false; }
                         break;
                     default: handled = false; break;
                 }
                 if (buttonToClick) {
                     const buttonElement = document.getElementById(buttonToClick);
                     if (buttonElement) {
                         buttonElement.click();
                         // Visual feedback for hotkey press
                         buttonElement.style.transform = 'scale(0.95)';
                         setTimeout(() => { buttonElement.style.transform = 'scale(1)'; }, 150);
                     }
                 }
                 if (handled) { e.preventDefault(); }
            });
            // Prevent mouse drag initiating on sliders/number inputs interfering with camera drag
            controlsDiv.querySelectorAll('input[type="range"], input[type="number"]').forEach(s=>{s.addEventListener('mousedown',(e)=>{ e.stopPropagation();});s.addEventListener('touchstart',(e)=>{ e.stopPropagation();},{passive:true});});


        }); // End DOMContentLoaded wrapper

        // --- Start Animation ---
        animate();

    </script>
</body>
</html>